<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BIO、NIO、AIO</title>
    <url>/2020/09/22/BIO%E3%80%81NIO%E3%80%81AIO/</url>
    <content><![CDATA[<h2 id="AIO、BIO、AIO的区别"><a href="#AIO、BIO、AIO的区别" class="headerlink" title="AIO、BIO、AIO的区别"></a>AIO、BIO、AIO的区别</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。</p>
<p>比如在A-&gt;B事件模型中，你需要先完成 A 才能执行B。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。</p>
<span id="more"></span>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p>
<h3 id="IO模型的主要分类："><a href="#IO模型的主要分类：" class="headerlink" title="IO模型的主要分类："></a>IO模型的主要分类：</h3><ul>
<li>同步(synchronous) IO和异步(asynchronous) IO</li>
<li>阻塞(blocking) IO和非阻塞(non-blocking)IO</li>
<li>同步阻塞(blocking-IO)简称BIO</li>
<li>同步非阻塞(non-blocking-IO)简称NIO</li>
<li>异步非阻塞(synchronous-non-blocking-IO)简称AIO</li>
</ul>
<p>在处理 IO 的时候，阻塞和非阻塞都是同步 IO。</p>
<h3 id="1-BIO同步阻塞"><a href="#1-BIO同步阻塞" class="headerlink" title="1.BIO同步阻塞"></a>1.BIO同步阻塞</h3><p>数据的读取写入必须阻塞在同一个线程内等待其完成。</p>
<p><img src="/images/pasted-134.png" class="lazyload" data-srcset="/images/pasted-134.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>伪异步IO</p>
<p><img src="/images/pasted-133.png" class="lazyload" data-srcset="/images/pasted-133.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="2-NIO同步非阻塞"><a href="#2-NIO同步非阻塞" class="headerlink" title="2.NIO同步非阻塞"></a>2.NIO同步非阻塞</h3><p>NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。</p>
<p>NIO 流是非阻塞 IO 而 IO 流是阻塞IO</p>
<ul>
<li>1)Non-blocking IO（非阻塞IO）<br>IO流是阻塞的，NIO流是不阻塞的。</li>
</ul>
<p>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了</p>
<ul>
<li>2)Buffer(缓冲区)<br>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</li>
</ul>
<p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p>
<p>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p>
<ul>
<li>3)Channel (通道)<br>NIO 通过Channel（通道） 进行读写。</li>
</ul>
<p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p>
<ul>
<li>4)Selector (选择器)<br>NIO有选择器，而IO没有。</li>
</ul>
<p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p>
<p>一个单线程中Selector维护3个Channel的示意图</p>
<p><img src="/images/pasted-135.png" class="lazyload" data-srcset="/images/pasted-135.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><strong>NIO 读数据和写数据方式</strong><br>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p>
<p>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</p>
<p>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。<br>数据读取和写入操作图示：</p>
<p><img src="/images/pasted-136.png" class="lazyload" data-srcset="/images/pasted-136.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>NIO读写数据的方式</p>
<p><strong>NIO核心组件简单介绍</strong></p>
<p>NIO 包含下面几个核心的组件：</p>
<ul>
<li>Channel(通道)</li>
<li>Buffer(缓冲区)</li>
<li>Selector(选择器)<br>整个NIO体系包含的类远远不止这三个，只能说这三个是NIO体系的“核心API”。</li>
</ul>
<h3 id="AIO异步IO"><a href="#AIO异步IO" class="headerlink" title="AIO异步IO"></a>AIO异步IO</h3><p>异步非阻塞的IO<br>AIO （ Asynchronous I/O）：异步非阻塞I/O模型。<br>异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。</p>
<p>对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。</p>
<blockquote>
<p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md#1non-blocking-io%E9%9D%9E%E9%98%BB%E5%A1%9Eio">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md#1non-blocking-io%E9%9D%9E%E9%98%BB%E5%A1%9Eio</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS原理</title>
    <url>/2020/08/30/CAS%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/weixin_43878293/article/details/102941568">https://blog.csdn.net/weixin_43878293/article/details/102941568</a></p>
]]></content>
  </entry>
  <entry>
    <title>Content-Type header [] is not supported 错误</title>
    <url>/2020/05/30/Content-Type-header-is-not-supported-%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h3 id="Content-Type-header-is-not-supported-error"><a href="#Content-Type-header-is-not-supported-error" class="headerlink" title="Content-Type header [] is not supported error"></a>Content-Type header [] is not supported error</h3><p>解决办法：添加</p>
<p><code>&#39;Content-Type&#39;: &#39;application/json&#39;</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>DCG计算</title>
    <url>/2020/12/30/DCG%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="DCG和NDCG的计算"><a href="#DCG和NDCG的计算" class="headerlink" title="DCG和NDCG的计算"></a>DCG和NDCG的计算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from math import log</span><br><span class="line"></span><br><span class="line">def gain(grade, maxGrade=4.0):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    当评分只有0和1时，gain的计算公式</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    return (2**grade - 1.0) / (2 ** maxGrade)</span><br><span class="line"></span><br><span class="line">def dcg(grades, n=0):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot; </span><br><span class="line">    当评分为多个值时使用的gain计算公式 </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if n &gt; len(grades):</span><br><span class="line">        raise ValueError(</span><br><span class="line">            &quot;dcg@%s cannot be calculated with %s grades&quot; % (n, len(grades)))</span><br><span class="line">    if n == 0:</span><br><span class="line">        n = len(grades)</span><br><span class="line"></span><br><span class="line">    dcg = 0</span><br><span class="line">    for i in range(0, n):</span><br><span class="line">        r = i + 1</span><br><span class="line">        dcg += grades[i] / log((r + 1), 2.0)</span><br><span class="line">    return dcg</span><br><span class="line">    </span><br><span class="line">def ndcg(grades, n=0):</span><br><span class="line">    return dcg(grades, n=n) / dcg(sorted(grades, reverse=True), n=n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>毕设</category>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title> Elasticsearch Mapping、字段类型Field type详解</title>
    <url>/2020/06/09/Elasticsearch-field-type/</url>
    <content><![CDATA[<h3 id="Elasticsearch-keyword-用法"><a href="#Elasticsearch-keyword-用法" class="headerlink" title="Elasticsearch keyword 用法"></a>Elasticsearch keyword 用法</h3><p><strong>keyword类型</strong></p>
<p>keyword类型适用于索引结构化的字段，比如email地址、主机名、状态码和标签。如果字段需要进行过滤(比如查找已发布博客中status属性为published的文章)、排序、聚合。keyword类型的字段只能通过精确值搜索到。</p>
<span id="more"></span>

<p>两种分词器使用的最佳实践是：索引时用ik_max_word，在搜索时用ik_smart。<br>即：索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_44062339/article/details/85006948">https://blog.csdn.net/weixin_44062339/article/details/85006948</a><br><a href="https://blog.csdn.net/weixin_44062339/article/details/85006948">https://blog.csdn.net/weixin_44062339/article/details/85006948</a><br><a href="https://blog.csdn.net/hello_world123456789/article/details/95341515">https://blog.csdn.net/hello_world123456789/article/details/95341515</a><br><a href="https://blog.csdn.net/raoxiaoya/article/details/90602296">https://blog.csdn.net/raoxiaoya/article/details/90602296</a><br><a href="https://blog.csdn.net/limingcai168/article/details/85780964?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase">https://blog.csdn.net/limingcai168/article/details/85780964?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a><br><a href="https://blog.csdn.net/ZYC88888/article/details/83059040">https://blog.csdn.net/ZYC88888/article/details/83059040</a><br><a href="https://blog.csdn.net/ZYC88888/article/details/83059040">https://blog.csdn.net/ZYC88888/article/details/83059040</a></p>
</blockquote>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>GBK编码错误</title>
    <url>/2020/05/28/GBK%E7%BC%96%E7%A0%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>1.<a href="https://www.cnblogs.com/ruiy/p/9091010.html">https://www.cnblogs.com/ruiy/p/9091010.html</a></p>
<p>2.json.dumps写入错误：<br><a href="https://www.cnblogs.com/shiju/p/9511916.html">https://www.cnblogs.com/shiju/p/9511916.html</a></p>
<p><code>new_ent_j = json.dumps(new_ent,ensure_ascii=False)</code></p>
<p><code>ascii</code>参数要为<code>false</code>，否则<code>json</code>会变为gbk编码</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>GBK编码</tag>
        <tag>json</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap,HashSet,Hashtable的区别</title>
    <url>/2020/08/30/HashMap-HashSet-Hashtable%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><p>1.继承的类不同，HashMap是基于AbstractMap实现了Map接口实现的，而Hashtable是基于Dictionary类</p>
<p>2.HashMap不是线程安全的，Hash table是线程安全的。</p>
<p>3.与不允许null的区别，Hashtable中，key和value都不允许出现null值，而在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p>
<p>4.遍历方式的内部实现上不同，Hashset、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式。</p>
<p>5.哈希值的使用不同<br>HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p>
<p>6.内部实现方式的数组的初始大小和扩容的方式不一样<br>HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>HashSet</tag>
        <tag>Hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/06/02/HashMap/</url>
    <content><![CDATA[<p>HashMap原理</p>
<h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h3><p>  HashMap很方便地为我们提供了key-value的形式存取数据，使用put方法存数据，get方法取数据。<br>  <span id="more"></span></p>
<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h3><p>  HashMap继承了Map接口，实现了Serializable等接口。HashMap的数据是存在table数组中的，它是一个Entry数组，Node是HashMap的一个静态内部类，看看它的定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br></pre></td></tr></table></figure>

<p>  可见，Node其实就是封装了key和value，也就是我们put方法参数的key和value会被封装成Entry，然后放到table这个Entry数组中。但值得注意的是，它有一个类型为Entry的next，它是用于指向下一个Entry的引用，所以table中存储的是Entry的单向链表。<br><img src="https://wx2.sbimg.cn/2020/06/02/Snipaste_2020-06-02_16-26-03.png" class="lazyload" data-srcset="https://wx2.sbimg.cn/2020/06/02/Snipaste_2020-06-02_16-26-03.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-02_16-26-03.png"></p>
<h3 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.构造方法"></a>3.构造方法</h3><p>构造方法一共有四个<br>initialCapacity是HashMap的初始化容量(即初始化table时用到)，默认为16。</p>
<p>loadFactor为负载因子，默认为0.75。<br>threshold是HashMap进行扩容的阀值，当HashMap的存放的元素个数超过该值时，会进行扩容，它的值为HashMap的容量乘以负载因子。比如，HashMap的默认阀值为16*0.75，即12</p>
<h3 id="4-put操作"><a href="#4-put操作" class="headerlink" title="4.put操作"></a>4.put操作</h3><p><img src="https://wx1.sbimg.cn/2020/06/02/Snipaste_2020-06-02_16-35-36.png" class="lazyload" data-srcset="https://wx1.sbimg.cn/2020/06/02/Snipaste_2020-06-02_16-35-36.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-02_16-35-36.png"></p>
<h3 id="5-扩容"><a href="#5-扩容" class="headerlink" title="5.扩容"></a>5.扩容</h3><p>扩容就是先创建一个长度为原来2倍的新table，然后通过遍历的方式，将老table的数据，重新计算hash并存储到新table的适当位置，最后使用新的table，并重新计算HashMap的扩容阀值。</p>
<h3 id="6-get"><a href="#6-get" class="headerlink" title="6.get"></a>6.get</h3><p>取值，最简单粗暴的方式肯定是遍历table，并且遍历table中存放的单向链表，这样的话，get的时间复杂度就是O(n的平方)，但是HashMap的put本身就是有规律的存储，所以，取值时，可以按照规律去降低时间复杂度。<br><img src="https://wx2.sbimg.cn/2020/06/02/Snipaste_2020-06-02_16-43-08.png" class="lazyload" data-srcset="https://wx2.sbimg.cn/2020/06/02/Snipaste_2020-06-02_16-43-08.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-02_16-43-08.png"></p>
<h3 id="7-使用entrySet取数据"><a href="#7-使用entrySet取数据" class="headerlink" title="7.使用entrySet取数据"></a>7.使用entrySet取数据</h3><p>HashMap除了提供get方法，通过key来取数据的方式，还提供了entrySet方法来遍历HashMap的方式取数据。</p>
<p><img src="https://wx1.sbimg.cn/2020/06/02/Snipaste_2020-06-02_17-02-13.png" class="lazyload" data-srcset="https://wx1.sbimg.cn/2020/06/02/Snipaste_2020-06-02_17-02-13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-02_17-02-13.png"></p>
<p>可知，HashMap的遍历，是先遍历table，然后再遍历table上每一条单向链表，如上述的HashMap遍历出来的顺序就是Entry1、Entry2….Entry6，但显然，这不是插入的顺序，所以说：HashMap是无序的。</p>
<h3 id="8-对key为null的处理"><a href="#8-对key为null的处理" class="headerlink" title="8.对key为null的处理"></a>8.对key为null的处理</h3><p>在HashMap中，不允许key重复，而key为null的情况，只允许一个key为null的Entry，并且存储在table[0]的单向链表上。</p>
<h3 id="9-remove方法"><a href="#9-remove方法" class="headerlink" title="9.remove方法"></a>9.remove方法</h3><p>先根据key算出hash，然后根据hash得到在table上的index，再遍历talbe[index]的单向链表，这时候需要看要删除的元素是否就是单向链表的表头，如果是，则直接让table[index]=next，即删除了需要删除的元素；如果不是单向链表的头，那表示有前面的结点，则让pre.next = next，也删除了需要删除的元素。</p>
<h3 id="10-线程安全问题"><a href="#10-线程安全问题" class="headerlink" title="10.线程安全问题"></a>10.线程安全问题</h3><p>由前面HashMap的put和get方法分析可得，put和get方法真实操作的都是Entry[] table这个数组，而所有操作都没有进行同步处理，所以HashMap是线程不安全的。如果想要实现线程安全，推荐使用ConcurrentHashMap。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>HashMap是基于哈希表实现的，用Entry[]来存储数据，而Entry中封装了key、value、hash以及Entry类型的next</li>
<li>HashMap存储数据是无序的</li>
<li>hash冲突是通过拉链法解决的</li>
<li>HashMap的容量永远为2的幂次方，有利于哈希表的散列</li>
<li>HashMap不支持存储多个相同的key，且只保存一个key为null的值，多个会覆盖</li>
<li>put过程，是先通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，看是否有相同的key存在，存在，则更新value；不存在则插入到table[index]单向链表的表头，时间复杂度为O(n)</li>
<li>get过程，通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，然后比对key，找到相同的key，则取出其value，时间复杂度为O(n)</li>
<li>HashMap是线程不安全的，如果有线程安全需求，推荐使用ConcurrentHashMap。</li>
</ul>
<p>作者：艺旭家<br>链接：<a href="https://www.jianshu.com/p/dde9b12343c1">https://www.jianshu.com/p/dde9b12343c1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/dde9b12343c1">https://www.jianshu.com/p/dde9b12343c1</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hashcode</title>
    <url>/2020/07/09/Hashcode/</url>
    <content><![CDATA[<h1 id="什么是Hashcode？"><a href="#什么是Hashcode？" class="headerlink" title="什么是Hashcode？"></a>什么是Hashcode？</h1><p>要理解hashcode首先要理解hash表</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>hash表也称散列表（Hash table），是根据关键码值（key value）而直接进行访问的数据结构。</p>
<p>它通过把关键码值映射到表中的一个位置来访问记录，以加快查找速度。这个映射函数称为散列函数，存放记录的数组叫做散列表。</p>
<span id="more"></span>
<ul>
<li><p>给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
</li>
<li><p>简单理解就是：在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。</p>
</li>
<li><p>具有快速查找和插入操作的优点</p>
</li>
</ul>
<h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><ul>
<li><p>hashcode 通过hash函数计算得到，hashcode就是hash表中有对应的位置。</p>
</li>
<li><p>每个对象都有hashcode，通过将对象的物理地址转换为一个整数，将整数通过hash计算就可以得到hashcode</p>
</li>
</ul>
<h1 id="hashcode的作用"><a href="#hashcode的作用" class="headerlink" title="hashcode的作用"></a>hashcode的作用</h1><p> HashCode的存在主要是为了查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的</p>
<pre><code>对于容器类设计 基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。</code></pre><p>   在对集合进行插入操作时，集合内时是不允许存在重复元素的，这样就引发了一个问题</p>
<p>  <font color=#DC143C size= 6>如何判别在集合中是否已经存在该对象了？</font> </p>
<p>  首先想到的方法就是调用equals()方法，这个方法确实可行。但是如果集合中已经存在大量的数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。 </p>
<p>  此时hashCode方法的作用就体现出来了，<br>  <strong>当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会一个表保存已经存进去的对象的hashcode值,</strong></p>
<p>  <strong>如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；</strong></p>
<p>  <strong>如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了</strong></p>
<p>  这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。</p>
<p>   所以说hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</p>
<h1 id="hashcode-和equals"><a href="#hashcode-和equals" class="headerlink" title="hashcode()和equals()"></a>hashcode()和equals()</h1><p>  <strong>Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码。equals()和hashCode()都不是final方法，都可以被重写(overwrite)</strong></p>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>  Object类中equals()方法实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该实现可以看出，Object类的实现采用了区分度最高的算法，即只要两个对象不是同一个对象，那么equals()一定返回false。</p>
<h2 id="hashcode方法"><a href="#hashcode方法" class="headerlink" title="hashcode方法"></a>hashcode方法</h2><p>   Object类中hashCode()方法的声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看出，hashCode()是一个native方法，而且返回值类型是整形；实际上，该native方法将对象在内存中的地址作为哈希码返回，可以保证不同对象的返回值不同。</p>
<p>与equals()方法类似，hashCode()方法可以被重写。JDK中对hashCode()方法的作用，以及实现时的注意事项做了说明：</p>
<p>（1）hashCode()在哈希表中起作用，如java.util.HashMap。</p>
<p>（2）如果对象在equals()中使用的信息都没有改变，那么hashCode()值始终不变。</p>
<p>（3）如果两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等。</p>
<p>（4）如果两个对象使用equals()方法判断为不相等，则不要求hashCode()也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的hashCode可以提高哈希表的性能。</p>
<p><strong>重写hashcode()的原则</strong></p>
<p>（1）如果重写了equals()方法，检查条件“两个对象使用equals()方法判断为相等，则hashCode()方法也应该相等”是否成立，如果不成立，则重写hashCode ()方法。</p>
<p>（2）hashCode()方法不能太过简单，否则哈希冲突过多。</p>
<p>（3）hashCode()方法不能太过复杂，否则计算复杂度过高，影响性能</p>
<h1 id="HashMap中的hash-函数"><a href="#HashMap中的hash-函数" class="headerlink" title="HashMap中的hash()函数"></a>HashMap中的hash()函数</h1><p>HashMap中并没有直接使用KV中K原有的hash值; 在HashMap的put、get操作时也未直接使用K中原有的hash值，而使用了一个hash()方法。让我们一起看一下这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="comment">//移位16位，保留高16位，再与key.hashcode()做异或操作</span></span><br><span class="line">    <span class="comment">//异或的规则是转换成二进制比较，相同为0，不同为1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码类似作用是为了增加hashcode的随机性</p>
<p>key.hashCode()的作用是返回键值key所属类型自带的hashcode，返回的类型是int，如果直接拿散列值作为下标访问HashMap的主数组的话，考虑到int类型值的范围[-2^31 , 2^31 -1]，虽然只要hash表映射比较松散的话，碰撞几率很小，但是映射空间太大，内存放不下，所以先做对数组的长度取模运算，得到的余数才能用来访问数组下标。</p>
<p>hashMap源码中模运算是在这个indexFor( )函数里完成的把散列值和数组长度-1做一个”与”操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123; <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为数组长度-1相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值.以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。h &amp; (length - 1) 和 h % length，它俩是等价不等效的，明显位运算效率非常高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   01111010 00111100 00100101</span><br><span class="line">&amp;  00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">   00000000 00000000 00000101</span><br><span class="line">  //高位全部归零，只保留末四位 </span><br></pre></td></tr></table></figure>

<p>but 只取后四位，即使散列值分布再松散，碰撞几率还是很大。更糟糕的是如果散列函数做的比较差吧，分布上是个等差数列啥的，恰好使最后几个低位呈现规律性重复，就比较蛋疼。</p>
<p>这时候 “hash”函数作用就出来了</p>
<p><strong>右位移16位，正好是32bit的一半，高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。</strong></p>
<p>设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，少了系统的开销，也不会造成因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。</p>
<p>根据研究结果显示，当HashMap数组长度为512的时候，也就是用掩码取低9位的时候，在没有使用hash()的情况下，发生了103次碰撞，接近30%。而在使用了hash()之后只有92次碰撞。碰撞减少了将近10%。看来扰hash()函数在将降低碰撞上还是有功效的。</p>
<p>hashMap中 MAXIMUM_CAPACITY = 1 &lt;&lt; 30;最大为2的30次方（超过这个值就将threshold修改为Integer.MAX_VALUE（此时表的大小已经是2的31次方了），表明不进行扩容了）</p>
<blockquote>
<p><a href="https://www.cnblogs.com/NathanYang/p/9427456.html">https://www.cnblogs.com/NathanYang/p/9427456.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
        <tag>hashcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Http协议</title>
    <url>/2020/07/07/Http%E5%92%8Chttps/</url>
    <content><![CDATA[<h1 id="HTTP-简介"><a href="#HTTP-简介" class="headerlink" title="HTTP 简介"></a>HTTP 简介</h1><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。</p>
<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<span id="more"></span>

<h2 id="HTTP-工作原理"><a href="#HTTP-工作原理" class="headerlink" title="HTTP 工作原理"></a>HTTP 工作原理</h2><p>HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p>
<ul>
<li>Web服务器有：Apache服务器，IIS服务器（Internet Information Services）,nginx,tomcat等。</li>
</ul>
<p>Web服务器根据接收到的请求后，向客户端发送响应信息。</p>
<p>HTTP默认端口号为80，但是你也可以改为8080或者其他端口。</p>
<h3 id="HTTP三点注意事项："><a href="#HTTP三点注意事项：" class="headerlink" title="HTTP三点注意事项："></a>HTTP三点注意事项：</h3><ul>
<li><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
</li>
<li><p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p>
</li>
<li><p>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
</li>
</ul>
<h3 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h3><p>下图表展示了HTTP协议通信流程</p>
<p><img src="/images/pasted-33.png" class="lazyload" data-srcset="/images/pasted-33.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>CGI(Common Gateway Interface) 是 HTTP 服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。</p>
<p>绝大多数的 CGI 程序被用来解释处理来自表单的输入信息，并在服务器产生相应的处理，或将相应的信息反馈给浏览器。CGI 程序使网页具有交互功能。</p>
<h2 id="Http消息结构"><a href="#Http消息结构" class="headerlink" title="Http消息结构"></a>Http消息结构</h2><p>HTTP是基于客户端/服务端（C/S）的架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。</p>
<p>一个HTTP”客户端”是一个应用程序（Web浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。</p>
<p>一个HTTP”服务器”同样也是一个应用程序（通常是一个Web服务，如Apache Web服务器或IIS服务器等），通过接收客户端的请求并向客户端发送HTTP响应数据。</p>
<p>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p>
<p>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式[RFC5322]和多用途Internet邮件扩展（MIME）[RFC2045]来传送。</p>
<h3 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h3><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。</p>
<p><img src="/images/pasted-34.png" class="lazyload" data-srcset="/images/pasted-34.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h3><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>
<p><img src="/images/pasted-35.png" class="lazyload" data-srcset="/images/pasted-35.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</p>
<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<h4 id="协议的八种请求类型"><a href="#协议的八种请求类型" class="headerlink" title="协议的八种请求类型"></a>协议的八种请求类型</h4><p>HTTP 协议中共定义了八种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式，具体介绍如下：</p>
<ul>
<li><p>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</p>
</li>
<li><p>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p>
</li>
<li><p>GET：向特定的资源发出请求。</p>
</li>
<li><p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<strong>POST请求可能会导致新的资源的创建和/或已有资源的修改</strong>。</p>
</li>
<li><p>PUT：向指定资源位置上传其最新内容。</p>
</li>
<li><p>DELETE：请求服务器删除 Request-URI 所标识的资源。</p>
</li>
<li><p>TRACE：回显服务器收到的请求，主要用于测试或诊断。</p>
</li>
<li><p>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</p>
</li>
<li><p>PATCH    是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p>
</li>
</ul>
<p>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。</p>
<h3 id="http请求实例"><a href="#http请求实例" class="headerlink" title="http请求实例"></a>http请求实例</h3><p>下面实例是一点典型的使用GET来传递数据的实例：</p>
<p>客户端请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /hello.txt HTTP/1.1</span><br><span class="line">User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3</span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept-Language: en, mi</span><br></pre></td></tr></table></figure>
<p>服务端响应:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 27 Jul 2009 12:28:53 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT</span><br><span class="line">ETag: &quot;34aa387-d-1568eb00&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 51</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><code>Hello World! My payload includes a trailing CRLF.</code></p>
<h3 id="http响应头信息"><a href="#http响应头信息" class="headerlink" title="http响应头信息"></a>http响应头信息</h3><blockquote>
<p><a href="https://www.runoob.com/http/http-messages.html">https://www.runoob.com/http/http-messages.html</a></p>
</blockquote>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><p>下面是常见的HTTP状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th align="center">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td align="center">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td align="center">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td align="center">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td align="center">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<h3 id="content-type"><a href="#content-type" class="headerlink" title="content-type"></a>content-type</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>IO多路复用</title>
    <url>/2020/09/22/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是IO多路复用？"><a href="#什么是IO多路复用？" class="headerlink" title="什么是IO多路复用？"></a>什么是IO多路复用？</h2><p>IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个句柄就绪，就能通知应用程序进行响应的IO操作；没有这个句柄就会阻塞应用程序，交出CPU使用权，多路指的是网络连接，复用指的是用同一个线程。<br>单线程或单进程同时监测若干个文件描述符是否可以执行IO操作。</p>
<span id="more"></span>
<h3 id="为什么会有IO多路复用机制？"><a href="#为什么会有IO多路复用机制？" class="headerlink" title="为什么会有IO多路复用机制？"></a>为什么会有IO多路复用机制？</h3><p><strong>同步阻塞BIO</strong><br>服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求（必须等上一个请求处recv或send完），无法处理并发。</p>
<p>只能通过增加线程数来处理并发。</p>
<p>服务器端采用多线程，当accept一个请求后，开启线程进行recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销，10000个线程真正发生读写事件的线程数不会超过20%，每次accept都开一个线程也是一种资源浪费</p>
<p><strong>同步非阻塞NIO</strong><br>服务器端当accept一个请求后，加入fds集合，每次轮询一遍fds集合recv(非阻塞)数据，没有数据则立即返回错误，每次轮询所有fd（包括没有发生读写事件的fd）会很浪费cpu。</p>
<p><strong>IO多路复用（现在的做法）</strong><br>服务器端采用单线程通过select/epoll等系统调用获取fd列表，遍历有事件的fd进行accept/recv/send，使其能支持更多的并发连接请求。</p>
<p><strong>文件描述符</strong><br>内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。</p>
<h3 id="IO多路复用的三种方式"><a href="#IO多路复用的三种方式" class="headerlink" title="IO多路复用的三种方式"></a>IO多路复用的三种方式</h3><ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select缺点：</p>
<ul>
<li>单个进程所打开的FD是有限制的，通过FD_SETSIZE设置，默认1024</li>
<li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>
<ul>
<li>每次调用poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li>
<li>对socket扫描时是线性扫描，采用轮询的方法，效率较低（高并发时）</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>应用于redis，nginx，只能工作在Linux下。</p>
<h3 id="select-poll-epoll之间的区别"><a href="#select-poll-epoll之间的区别" class="headerlink" title="select/poll/epoll之间的区别"></a>select/poll/epoll之间的区别</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="left">select</th>
<th align="left">poll</th>
<th align="left">epoll</th>
</tr>
</thead>
<tbody><tr>
<td align="left">数据结构</td>
<td align="left">bitmap</td>
<td align="left">数组</td>
<td align="left">红黑树</td>
</tr>
<tr>
<td align="left">最大连接数</td>
<td align="left">1024</td>
<td align="left">无上限</td>
<td align="left">无上限</td>
</tr>
<tr>
<td align="left">fd拷贝</td>
<td align="left">每次调用select拷贝</td>
<td align="left">每次调用poll拷贝</td>
<td align="left">fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td>
</tr>
<tr>
<td align="left">工作效率</td>
<td align="left">轮询：O(n)</td>
<td align="left">轮询：O(n)</td>
<td align="left">回调：O(1)</td>
</tr>
</tbody></table>
<h3 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h3><p>select</p>
<ol>
<li>首先从用户空间拷贝fd_set到内核空间</li>
<li>注册回调函数pollwait，pollwait的主要作用就是将当前进程挂载到设备的等待队列</li>
<li>遍历fd，调用其对应的poll方法</li>
<li>poll方法会返回一个描述读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。</li>
<li>遍历完fd如果没有返回一个可读写的掩码，则会调用select的进程进入睡眠状态。如果设备发生自身资源可读写后，回唤醒等待队列上的进程。</li>
<li>把fd_set从内核空间拷贝回用户空间。</li>
</ol>
<p>poll</p>
<blockquote>
<p><a href="https://juejin.im/post/6844904200141438984">https://juejin.im/post/6844904200141438984</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载机制和双亲委派模型</title>
    <url>/2020/08/30/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://juejin.im/post/6844903633574690824">https://juejin.im/post/6844903633574690824</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>JVM之堆栈</title>
    <url>/2020/09/13/JVm/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/yychuyu/p/13275970.html">https://www.cnblogs.com/yychuyu/p/13275970.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 类和对象内存分配</title>
    <url>/2020/06/29/Java-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p><img src="/images/pasted-16.png" class="lazyload" data-srcset="/images/pasted-16.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>Java中方法传递参数是按值传递：</p>
<ul>
<li><p>如果是基本类型，则值  代表元素内容</p>
</li>
<li><p>如果是引用类型，则值  代表地址号</p>
<span id="more"></span>

</li>
</ul>
<h3 id="一个类示例："><a href="#一个类示例：" class="headerlink" title="一个类示例："></a>一个类示例：</h3><p><img src="/images/pasted-12.png" class="lazyload" data-srcset="/images/pasted-12.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="类变量总是比实例变量先初始化"><a href="#类变量总是比实例变量先初始化" class="headerlink" title="类变量总是比实例变量先初始化"></a>类变量总是比实例变量先初始化</h3><p><img src="/images/pasted-11.png" class="lazyload" data-srcset="/images/pasted-11.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>错误示例：<br><img src="/images/pasted-13.png" class="lazyload" data-srcset="/images/pasted-13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="类的加载时机："><a href="#类的加载时机：" class="headerlink" title="类的加载时机："></a>类的加载时机：</h2><h3 id="类加载的生命周期"><a href="#类加载的生命周期" class="headerlink" title="类加载的生命周期"></a>类加载的生命周期</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中 验证、准备、解析 3 个部分统称为连接，这 7 个阶段的发生顺序如下图所示。</p>
<p><img src="/images/pasted-14.png" class="lazyload" data-srcset="/images/pasted-14.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="类在实例化后的内存分配"><a href="#类在实例化后的内存分配" class="headerlink" title="类在实例化后的内存分配"></a>类在实例化后的内存分配</h2><p><img src="/images/pasted-15.png" class="lazyload" data-srcset="/images/pasted-15.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>1.每次创建对象时，都需要进行加载和创建2个操作：</p>
<p>① 先去判断需要的类是否已经加载，如果已经加载了，则无需再加载，如果没有加载，则需要通过类加载器加载类信息到方法区</p>
<p>② 在堆中创建新对象</p>
<p>2、栈、堆、方法区的存储</p>
<p>栈：方法执行时创建方法栈帧，存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中。</p>
<p>堆：对象和成员变量</p>
<p>方法区：与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>
<p>java中的全局变量，也就是class的字段，存放在方法区中.</p>
<p>对于局部变量，如果是基本类型，会把值直接存储在栈；如果是引用类型，比如String s = new String(“william”);会把其对象存储在堆，而把这个对象的引用（指针）存储在栈。<br>再如<br>String s1 = new String(“william”);<br>String s2 = s1;<br>s1和s2同为这个字符串对象的实例，但是对象只有一个，存储在堆，而这两个引用存储在栈中。</p>
<p>3、方法的调用机制</p>
<p>每次调用方法，伴随着“方法入栈”操作，也就是栈中为该方法分配了一块空间，用于保存该方法中涉及到的变量</p>
<p>每次方法调用结束，伴随着“方法出栈”操作，也就是栈中分配的空间被释放了</p>
<p>在类的方法调用过程中，首先判断方法区是否存在该方法，存在则方法入栈，调用结束后出栈。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Birthday birthday = <span class="keyword">new</span> Birthday();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Birthday</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year = <span class="number">2010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> month = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-17.png" class="lazyload" data-srcset="/images/pasted-17.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>从图中我们可以看出，普通的java实例对象内存分配，主要在这三个区域：虚拟机栈、堆、方法区。</p>
<p><img src="/images/pasted-18.png" class="lazyload" data-srcset="/images/pasted-18.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-19.png" class="lazyload" data-srcset="/images/pasted-19.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-20.png" class="lazyload" data-srcset="/images/pasted-20.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="从内存区域来分析"><a href="#从内存区域来分析" class="headerlink" title="从内存区域来分析"></a>从内存区域来分析</h3><p>虚拟机栈:只存放局部变量</p>
<p>堆:存储对象的实例</p>
<p>方法区：存放Class信息和常量信息，static变量。</p>
<p>•     成员变量：堆内存</p>
<p>•     局部变量：栈内存</p>
<h3 id="从变量的角度来分析"><a href="#从变量的角度来分析" class="headerlink" title="从变量的角度来分析"></a>从变量的角度来分析</h3><ul>
<li>局部变量：存放在虚拟机栈中（具体应为[栈-&gt;栈帧-&gt;局部变量表]）<br> 基本类型的值直接存在栈中。如age=10<br> 如果是对象的实例，则只存储对象实例的引用。如s=ref</li>
<li>实例变量：存放在堆中的对象实例中。如Student的实例变量 name=ref</li>
<li>静态变量：存放在方法区中的常量池中。如Student.class中的birthday=ref。</li>
</ul>
<p>如果常量的类型是对象的实例则只存储对象实例的引用地址</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存分配</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 死锁的四个必要条件和死锁预防、检测、避免、解除</title>
    <url>/2020/08/27/Java-%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h3 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h3><p>一组相互竞争资源的线程因为互相等待，导致“永久”阻塞的现象。</p>
<h3 id="死锁发生的四个必要条件"><a href="#死锁发生的四个必要条件" class="headerlink" title="死锁发生的四个必要条件"></a>死锁发生的四个必要条件</h3><ul>
<li>互斥，共享资源 X 和 Y 只能被一个线程占用；</li>
<li>占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；</li>
<li>不可抢占，其他线程不能强行抢占线程 T1 占有的资源；</li>
<li>循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。<span id="more"></span>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3></li>
</ul>
<ol>
<li><p>jps + jstack</p>
</li>
<li><p>jconsole</p>
</li>
<li><p>Java Visual VM</p>
</li>
<li><p>找到cpu占用较高的线程TID</p>
</li>
<li><p>通过jstack -l &lt; PID &gt; 输出当前进程的线程信息</p>
</li>
</ol>
<p><img src="/images/pasted-62.png" class="lazyload" data-srcset="/images/pasted-62.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="预防死锁的发生"><a href="#预防死锁的发生" class="headerlink" title="预防死锁的发生"></a>预防死锁的发生</h3><p>主要思想： 破坏死锁发生的条件。<br>四个条件中我们不能破坏互斥条件，所以只能对其他三个条件进行破坏。</p>
<ul>
<li>占用且等待：一次性申请所有的资源，这样就不存在等待了。</li>
<li>不可抢占：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li>循环等待：存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。</li>
</ul>
<h3 id="两种常用的死锁接触"><a href="#两种常用的死锁接触" class="headerlink" title="两种常用的死锁接触"></a>两种常用的死锁接触</h3><p>1) 资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</p>
<p>2) 撤销进程法。强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</p>
<blockquote>
<p><a href="https://blog.csdn.net/u010648555/article/details/80721815">https://blog.csdn.net/u010648555/article/details/80721815</a><br><a href="https://www.cnblogs.com/myworld7/p/12230010.html#_labelTop">https://www.cnblogs.com/myworld7/p/12230010.html#_labelTop</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程池的拒绝策略</title>
    <url>/2020/09/19/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>RejectedExecutionHandler提供了四种方式来处理任务拒绝策略</p>
<p>1、直接丢弃（DiscardPolicy）</p>
<p>2、丢弃队列中最老的任务(DiscardOldestPolicy)。</p>
<p>3、抛异常(AbortPolicy)</p>
<p>4、将任务分给调用线程来执行(CallerRunsPolicy)。</p>
<span id="more"></span>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程池是一种基于池化思想管理线程的工具，经常出现在多线程服务器中。</p>
<p>主要思想就是：由于线程过多会带来额外的开销，包括线程创建和销毁的开销，调度线程的开销，降低了计算机整体性能，线程池维护多个线程，等待监督管理者分配可并发执行的任务。这样减少了线程创建销毁的开销，避免了线程数量膨胀导致过分调度问题，保证对内核的充分调用。</p>
<h3 id="线程池参数："><a href="#线程池参数：" class="headerlink" title="线程池参数："></a>线程池参数：</h3><p>corePoolSize： 线程池维护线程的最少数量</p>
<p>maximumPoolSize：线程池维护线程的最大数量</p>
<p>keepAliveTime： 线程池维护线程所允许的空闲时间</p>
<p>unit： 线程池维护线程所允许的空闲时间的单位</p>
<p>workQueue： 线程池所使用的缓冲队列</p>
<p>handler： 线程池对拒绝任务的处理策略</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础(面试)</title>
    <url>/2020/08/28/Java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数组</title>
    <url>/2020/06/05/Java%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h2><h3 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h3><p>数组（Array）是有序的元素序列，数组是在堆内存中开辟一段连实的空间，并在此空间存放元素。<br>数组长度一旦声明,不可改变不可追加</p>
<span id="more"></span>
<h3 id="（2）结构特点"><a href="#（2）结构特点" class="headerlink" title="（2）结构特点"></a>（2）结构特点</h3><ul>
<li>查找元素快</li>
<li>增删元素慢</li>
</ul>
<p>1、数组查询快：数组的地址是连续的我们通过数组的首地址可以找到数组，通过数组的素引可以快速查找某一个元素</p>
<p>2、元素增删慢：数组的长度是固定的我们想要增加/删除一个元素，必须创建一个新数组把源数组的数据复制过来</p>
<p>3、增删元素，会在堆内存中频繁的创建新数组、复制数组中的元素、销毁数组，导致效率低下</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java是编译型还是解释型？</title>
    <url>/2020/09/10/Java%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%BF%98%E6%98%AF%E8%A7%A3%E9%87%8A%E5%9E%8B%EF%BC%9F/</url>
    <content><![CDATA[<ul>
<li><p>编译型语言（compiled language）指通过编译器（compiler）将源代码编译为机器码（machine code）后运行的语言，例如C、C++；</p>
</li>
<li><p>解释型语言（interpreted language）指由解释器（interpreter）直接执行，不需要编译成机器语言，例如 PHP、JavaScript。</p>
<span id="more"></span>
<p>编译型语言和解释型语言的优点和缺点：由于解释型语言会在运行时翻译源代码，一般情况下运行速度不如编译型语言；解释型语言由解释器运行，而不是直接运行在操作系统上，所以一般有较强的跨平台能力。</p>
</li>
</ul>
<p>Java 是编译型语言还是解释型语言：为了兼顾跨平台和运行速度，Java 源代码首先会被编译为字节码文件（.class），但并非是机器语言，而是需要在 JVM 上运行，而 .class 文件在 JVM 上是解释执行的。所以 Java 兼具编译型语言和解释型语言的特点。</p>
<p>为了更高的效率，JVM 还引入了 JIT（just-in-time，即时编译）编译器，在 Java 程序运行时进一步编译，转换成高度优化的机器代码。现在的很多语言以及不能以编译型语言和解释型语言来区分了，因为很多语言都兼具编译型语言和解释型语言的特点。</p>
<blockquote>
<p>作者：叉叉哥<br>链接：<a href="https://www.zhihu.com/question/19608553/answer/1388597692">https://www.zhihu.com/question/19608553/answer/1388597692</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序的执行过程</title>
    <url>/2020/08/27/Java%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/images/pasted-63.png" class="lazyload" data-srcset="/images/pasted-63.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<blockquote>
<p><a href="https://juejin.im/post/6844903696996941832">https://juejin.im/post/6844903696996941832</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java读取txt文本</title>
    <url>/2020/08/30/Java%E8%AF%BB%E5%8F%96txt%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<p><img src="/images/pasted-67.png" class="lazyload" data-srcset="/images/pasted-67.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs.ms;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTxt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String filepath = <span class="string">&quot;E:\\Avscode\\erchashu\\ys\\src\\main\\java\\hs\\ms\\a.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(filepath);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行操作</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        isr.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit测试单元</title>
    <url>/2020/06/02/Junit%E6%B5%8B%E8%AF%95%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<h2 id="junit测试单元"><a href="#junit测试单元" class="headerlink" title="junit测试单元"></a>junit测试单元</h2><h3 id="1-什么是-JUnit？"><a href="#1-什么是-JUnit？" class="headerlink" title="1.什么是 JUnit？"></a>1.什么是 JUnit？</h3><p>JUnit 是一个 Java 编程语言的单元测试框架。JUnit 在测试驱动的开发方面有很重要的发展，是起源于 JUnit 的一个统称为 xUnit 的单元测试框架之一。</p>
<span id="more"></span>
<p>JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。这个方法就好比“测试一点，编码一点，测试一点，编码一点……”，增加了程序员的产量和程序的稳定性，可以减少程序员的压力和花费在排错上的时间。</p>
<h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="2.特点："></a>2.特点：</h3><ul>
<li>JUnit 是一个开放的资源框架，用于编写和运行测试。</li>
<li>提供注释来识别测试方法。</li>
<li>提供断言来测试预期结果。</li>
<li>提供测试运行来运行测试。</li>
<li>JUnit 测试允许你编写代码更快，并能提高质量。</li>
<li>JUnit 优雅简洁。没那么复杂，花费时间较少。</li>
<li>JUnit 测试可以自动运行并且检查自身结果并提供即时反馈。所以也没有必要人工梳理测试结果的报告。</li>
<li>JUnit 测试可以被组织为测试套件，包含测试用例，甚至其他的测试套件。</li>
<li>JUnit 在一个条中显示进度。如果运行良好则是绿色；如果运行失败，则变成红色。</li>
</ul>
<h3 id="3-什么是一个单元测试用例"><a href="#3-什么是一个单元测试用例" class="headerlink" title="3.什么是一个单元测试用例?"></a>3.什么是一个单元测试用例?</h3><p>单元测试用例是一部分代码，可以确保另一端代码（方法）按预期工作。为了迅速达到预期的结果，就需要测试框架。JUnit 是 java 编程语言理想的单元测试框架。</p>
<p>一个正式的编写好的单元测试用例的特点是：已知输入和预期输出，即在测试执行前就已知。已知输入需要测试的先决条件，预期输出需要测试后置条件。</p>
<p>每一项需求至少需要两个单元测试用例：一个正检验，一个负检验。如果一个需求有子需求，每一个子需求必须至少有正检验和负检验两个测试用例。</p>
<p>测试用class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJunit</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String str= <span class="string">&quot;Junit is working fine&quot;</span>;</span><br><span class="line">      assertEquals(<span class="string">&quot;Junit is working fine&quot;</span>,str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.JUnitCore;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.Result;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.notification.Failure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestRunner</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Result result = JUnitCore.runClasses(TestJunit.class);</span><br><span class="line">      <span class="keyword">for</span> (Failure failure : result.getFailures()) &#123;</span><br><span class="line">         System.out.println(failure.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(result.wasSuccessful());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出true</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>测试</tag>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title>KBQA的核心任务</title>
    <url>/2020/05/29/KBQA%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/114125502">https://zhuanlan.zhihu.com/p/114125502</a></p>
</blockquote>
<h3 id="知识体系构建（KB）"><a href="#知识体系构建（KB）" class="headerlink" title="知识体系构建（KB）"></a>知识体系构建（KB）</h3><ul>
<li>基于业务特点，梳理知识体系；</li>
<li>非结构化输入文本抽取三元组（主实体Subject，关系Predicate，客实体Object），并以特定方式进行存储（通常为图数据库）。<br>如：”周星驰的电影功夫上映于2004年”，包含两对三元组（周星驰，拍摄的电影，功夫），（功夫，上映时间，2004年）；<span id="more"></span>
<h3 id="标准问答查询（QA）"><a href="#标准问答查询（QA）" class="headerlink" title="标准问答查询（QA）"></a>标准问答查询（QA）</h3>(1)关系实体抽取</li>
<li>查询语句抽取二元组（主实体Subject，关系Predicate）；</li>
<li>如：”功夫上映于哪一年”，包含一对二元组（功夫，上映时间）；</li>
</ul>
<p>(2)实体消歧</p>
<ul>
<li>解决同名实体产生歧义的问题；</li>
<li>如：周星驰和星爷应对应同一实体；</li>
</ul>
<p>(3)关系链接</p>
<ul>
<li>将抽取得到的实体与关系进行链接，保证链接后的实体关系在知识体系中是有效的；</li>
<li>如：豆瓣影评任务下询问”周星驰的母亲叫什么名字”，所得到的二元组（周星驰，母亲）是非法的，因为知识体系中未建立该关系；</li>
</ul>
<p>(4)结果查询</p>
<ul>
<li>在知识体系中检索合法的关系实体对，获取结果输出。</li>
</ul>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap</title>
    <url>/2020/06/02/LinkedHashMap/</url>
    <content><![CDATA[<h2 id="LinkedHashMap使用与实现"><a href="#LinkedHashMap使用与实现" class="headerlink" title="LinkedHashMap使用与实现"></a>LinkedHashMap使用与实现</h2><p>LinkedHashMap</p>
<span id="more"></span>
<p><img src="https://wx2.sbimg.cn/2020/06/02/Snipaste_2020-06-02_19-47-27.png" class="lazyload" data-srcset="https://wx2.sbimg.cn/2020/06/02/Snipaste_2020-06-02_19-47-27.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-02_19-47-27.png"></p>
<p>HashMap是无序的，LinkedHashMap是有序的</p>
<h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1.简单使用"></a>1.简单使用</h3><p>LinkedHashMap是有序的，且默认为插入顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">linkHp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;name1&quot;</span>, <span class="string">&quot;josan1&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;name2&quot;</span>, <span class="string">&quot;josan2&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;name3&quot;</span>, <span class="string">&quot;josan3&quot;</span>);</span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; set = linkedHashMap.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : set) &#123;</span><br><span class="line">            String key = (String) entry.getKey();</span><br><span class="line">            String value = (String) entry.getValue();</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span> + key + <span class="string">&quot;,value:&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h3><p>LinkedHashMap存储数据是有序的，而且分为两种：插入顺序和访问顺序。</p>
<p>这里accessOrder设置为false，表示不是访问顺序而是插入顺序存储的，这也是默认值，表示LinkedHashMap中存储的顺序是按照调用put方法插入的顺序进行排序的</p>
<p>LinkedHashMap构造函数，主要就是调用HashMap构造函数初始化了一个Entry[] table，然后调用自身的init初始化了一个只有头结点的双向链表。完成了如下操作：</p>
<p><img src="https://wx1.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-15-56.png" class="lazyload" data-srcset="https://wx1.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-15-56.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-03_21-15-56.png"></p>
<p>当put元素时，不但要把它加入到HashMap中去，还要加入到双向链表中，所以可以看出LinkedHashMap就是HashMap+双向链表，下面用图来表示逐步往LinkedHashMap中添加数据的过程，红色部分是双向链表，黑色部分是HashMap结构，header是一个Entry类型的双向链表表头，本身不存储数据。</p>
<p>加入一个Entry时</p>
<p><img src="https://wx2.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-21-30.png" class="lazyload" data-srcset="https://wx2.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-21-30.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-03_21-21-30.png"></p>
<p>再加入一个元素Entry2，假设index 为15<br><a href="https://sbimg.cn/image/kelCa"><img src="https://wx1.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-26-17.png" class="lazyload" data-srcset="https://wx1.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-26-17.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-03_21-26-17.png"></a></p>
<p>当再加入一个元素Entry3, 假设index也是0：<br><img src="https://wx2.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-27-56.png" class="lazyload" data-srcset="https://wx2.sbimg.cn/2020/06/03/Snipaste_2020-06-03_21-27-56.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Snipaste_2020-06-03_21-27-56.png"><br>就是LinkedHashMap的put的所有过程了，总体来看，跟HashMap的put类似，只是多了把新增的Entry加入到双向链表中。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
        <tag>LinkedHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下查看正在运行的Java程序</title>
    <url>/2020/08/30/Linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84Java%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>查看所有java进程 <code>ps -ef | grep java</code> </p>
<p>停止所有java进程 <code>pkill -9</code></p>
<p>停止特定的java命令 <code>kill -9 进程pid</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>List,Map和Set的区别</title>
    <url>/2020/08/30/List-Maphe-Set%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有人想有可以自动扩展的数组,所以有了List</span><br><span class="line">有的人想有没有重复的数组,所以有了set</span><br><span class="line">有人想有自动排序的组数,所以有了TreeSet,TreeList,TreeMap</span><br><span class="line"> </span><br><span class="line">而几乎有有的集合都是基于数组来实现的.</span><br><span class="line">因为集合是对数组做的封装,所以,数组永远比任何一个集合要快</span><br><span class="line"> </span><br><span class="line">但任何一个集合,比数组提供的功能要多</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="List-和-Set"><a href="#List-和-Set" class="headerlink" title="List 和 Set"></a>List 和 Set</h3><p>两个接口都是继承自Collection是常用来存放数据项的集合，主要区别如下：</p>
<p>① List和Set之间很重要的一个区别是是否允许重复元素的存在，在List中允许插入重复的元素，而在Set中不允许重复元素存在。</p>
<p>② 与元素先后存放顺序有关，List是有序集合，会保留元素插入时的顺序，Set是无序集合。</p>
<p>③ List可以通过下标来访问，而Set不能。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>　因为List和Set都实现了Collection接口的addAll(Collection&lt;? extends E&gt; c)方法，因此可以采用addAll()方法将List和Set互相转换；另外，List和Set也提供了Collection&lt;? extends E&gt; c作为参数的构造函数，因此通常采用构造函数的形式完成互相转化。</p>
<blockquote>
<p><a href="https://blog.csdn.net/SpeedMe/article/details/22398395">https://blog.csdn.net/SpeedMe/article/details/22398395</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>List</tag>
        <tag>Map</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven配置及使用</title>
    <url>/2020/09/08/Maven%E4%B8%ADpom-xml%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><img src="/images/pasted-126.png" class="lazyload" data-srcset="/images/pasted-126.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<h2 id="maven是什么？"><a href="#maven是什么？" class="headerlink" title="maven是什么？"></a>maven是什么？</h2><p>是一个项目管理和综合工具。<br>提供开发人员构建一个完整的生命周期开发框架，可以自动完成项目的基础工具建设，maven使用标准的目录机构和默认构建生命周期。</p>
<p>类似的工具还有Gradle。</p>
<h2 id="maven是干什么的？"><a href="#maven是干什么的？" class="headerlink" title="maven是干什么的？"></a>maven是干什么的？</h2><p>简单来说就是一个导jar包的工具，把jar包集中管理。</p>
<h2 id="maven本地仓库"><a href="#maven本地仓库" class="headerlink" title="maven本地仓库"></a>maven本地仓库</h2><p>（略）<br>修改setting.xml中仓库地址 </p>
<h2 id="pom-xml配置"><a href="#pom-xml配置" class="headerlink" title="pom.xml配置"></a>pom.xml配置</h2><p>POM <code>project object model</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 基本配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>hs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ys<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 项目基本信息 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>ys<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project&#x27;s website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 定义pom常量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 依赖配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">&lt;!-- 构建配置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span><span class="comment">&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用的插件列表 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-clean-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-install-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-deploy-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 创建一个POM之前，应该要先决定项目组(groupId)，项目名(artifactId)和版本（version）</p>
<p>部分项目组件已经标在上面的xml中。其他的可以参考下面第二个链接。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/whgk/p/7112560.html">https://www.cnblogs.com/whgk/p/7112560.html</a><br><a href="https://www.jianshu.com/p/0e3a1f9c9ce7">https://www.jianshu.com/p/0e3a1f9c9ce7</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql B+索引</title>
    <url>/2020/09/07/Mysql-B-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>各个数据页可以组成一个双向链表，而每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，</p>
<p>每个数据页都会为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</p>
<span id="more"></span>
<p><img src="/images/pasted-113.png" class="lazyload" data-srcset="/images/pasted-113.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>页abc可以不在物理存储结构上相连，只要通过双向链表相关联。</p>
<h3 id="没有索引的查找"><a href="#没有索引的查找" class="headerlink" title="没有索引的查找"></a>没有索引的查找</h3><h4 id="一个页面查找"><a href="#一个页面查找" class="headerlink" title="一个页面查找"></a>一个页面查找</h4><ol>
<li>主键为搜索条件：在页目录中二分查找</li>
<li>其他列： 遍历单链表</li>
</ol>
<h4 id="多个页面查找"><a href="#多个页面查找" class="headerlink" title="多个页面查找"></a>多个页面查找</h4><ol>
<li>定位到记录所在页</li>
<li>从所在页找到相应记录</li>
</ol>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p><img src="/images/pasted-115.png" class="lazyload" data-srcset="/images/pasted-115.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>我们只在示意图里展示记录的这几个部分：<br><code>record_type</code>：记录头信息的一项属性，表示记录的类型，0表示普通记录、2表示最小记录、3表示最大记录、1我们还没用过，等会再说</p>
<p><code>next_record</code>：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，为了方便大家理解，我们都会用箭头来表明下一条记录是谁。</p>
<p>各个列的值：这里只记录在index_demo表中的三个列，分别是c1、c2和c3。</p>
<p>其他信息：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p>
<p><img src="/images/pasted-114.png" class="lazyload" data-srcset="/images/pasted-114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="一个简单的索引方案"><a href="#一个简单的索引方案" class="headerlink" title="一个简单的索引方案"></a>一个简单的索引方案</h3><p><font color = red>因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所<br>以 不得不 依次遍历所有的数据页。</font></p>
<p>建立索引需要：</p>
<ol>
<li>下一个数据页中用户记录的主键值必须大于上一个野种用户记录的主键值</li>
<li>给所有的页建立一个目录项。</li>
</ol>
<h4 id="一个插入过程"><a href="#一个插入过程" class="headerlink" title="一个插入过程"></a>一个插入过程</h4><p><img src="/images/pasted-116.png" class="lazyload" data-srcset="/images/pasted-116.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>再插入一条记录4</p>
<p><img src="/images/pasted-117.png" class="lazyload" data-srcset="/images/pasted-117.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-118.png" class="lazyload" data-srcset="/images/pasted-118.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br><font color = red>新分配的数据页编号可能并不是连续的，也就是说我们使用的这些页在存储空间里可能并不挨着</font></p>
<p><img src="/images/pasted-119.png" class="lazyload" data-srcset="/images/pasted-119.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>页面不连续，所以插入数据后数据页可能变成下面这样<br><img src="/images/pasted-120.png" class="lazyload" data-srcset="/images/pasted-120.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>最终页目录</p>
<p><img src="/images/pasted-121.png" class="lazyload" data-srcset="/images/pasted-121.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>这个目录有一个别名，称为索引。</p>
<h2 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h2><p>这些目录项其实长得跟我们的用户记录差不多，只不过目录项中的<strong>两个列是主键和页号</strong>而已，所以他们复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为目录项记录。</p>
<p>记录头信息里的record_type属性，它的各个取值代表的意思如下：<br>0. 普通的用户记录</p>
<ol>
<li>目录项记录</li>
<li>最小记录</li>
<li>最大记录</li>
</ol>
<p><img src="/images/pasted-122.png" class="lazyload" data-srcset="/images/pasted-122.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调一遍目录项记录和普通的用户记录的不同点：</p>
<ul>
<li><font color = red>目录项记录的record_type值是1，而普通用户记录的record_type值是0</font>。</li>
<li>目录项记录只有主键值和页的编号两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有InnoDB自己添加的隐藏列。</li>
<li>还记得我们之前在唠叨记录头信息的时候说过一个叫min_rec_mask的属性么，只有在存储目录项记录的页中的主键值最小的目录项记录的min_rec_mask值为1，其他别的记录的min_rec_mask值都是0。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>B+Tree</tag>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql InnoDB数据页结构</title>
    <url>/2020/09/04/Mysql-InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><img src="/images/pasted-103.png" class="lazyload" data-srcset="/images/pasted-103.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<h2 id="不同类型页"><a href="#不同类型页" class="headerlink" title="不同类型页"></a>不同类型页</h2><p>数据页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。InnoDB为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放<code>Insert Buffer</code>信息的页，存放<code>INODE</code>信息的页，存放<code>undo</code>日志信息的页等</p>
<h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p><img src="/images/pasted-103.png" class="lazyload" data-srcset="/images/pasted-103.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>一个InnoDB数据页的存储空间大致被划分成了7个部分，有的部分占用字节数是确定的，有的不是。</p>
<p><img src="/images/pasted-104.png" class="lazyload" data-srcset="/images/pasted-104.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="数据插入过程"><a href="#数据插入过程" class="headerlink" title="数据插入过程"></a>数据插入过程</h3><p><img src="/images/pasted-105.png" class="lazyload" data-srcset="/images/pasted-105.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>数据结构构造的主要思想：</p>
<ol>
<li>分组</li>
<li>把每组主键最大最小记录单列出来</li>
<li>把每组主键最大最小的记录在页目录page directory排列成数组便于二分查找</li>
</ol>
<h4 id="最大最小记录"><a href="#最大最小记录" class="headerlink" title="最大最小记录"></a>最大最小记录</h4><p><img src="/images/pasted-106.png" class="lazyload" data-srcset="/images/pasted-106.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>我们的记录按照主键从小到大的顺序形成了一个单链表。</p>
<p>最大记录的next_record的值为0，这也就是说最大记录是没有下一条记录了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：</p>
<p><img src="/images/pasted-107.png" class="lazyload" data-srcset="/images/pasted-107.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><strong>对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1-8 条之间，剩下的分组中记录的条数范围只能在是 4-8 条之间</strong><br><img src="/images/pasted-108.png" class="lazyload" data-srcset="/images/pasted-108.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="数据查找"><a href="#数据查找" class="headerlink" title="数据查找"></a>数据查找</h3><p>所以在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ol>
<li>通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。</li>
<li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li>
</ol>
<h3 id="页面头部（page-header）"><a href="#页面头部（page-header）" class="headerlink" title="页面头部（page header）"></a>页面头部（page header）</h3><p><img src="/images/pasted-109.png" class="lazyload" data-srcset="/images/pasted-109.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="文件头部（file-header）"><a href="#文件头部（file-header）" class="headerlink" title="文件头部（file header）"></a>文件头部（file header）</h3><p><img src="/images/pasted-110.png" class="lazyload" data-srcset="/images/pasted-110.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-111.png" class="lazyload" data-srcset="/images/pasted-111.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>文件头部有FIL_PAGE_PREV和FIL_PAGE_NEXT指针分别指向上下页<br>双链表<br><img src="/images/pasted-112.png" class="lazyload" data-srcset="/images/pasted-112.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个数据页可以被大致划分为7个部分，分别是</p>
<ul>
<li>File Header，表示页的一些通用信息，占固定的38字节。</li>
<li>Page Header，表示数据页专有的一些信息，占固定的56个字节。</li>
<li>Infimum + Supremum，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节。</li>
<li>User Records：真实存储我们插入的记录的部分，大小不固定。</li>
<li>Free Space：页中尚未使用的部分，大小不确定。</li>
<li>Page Directory：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。</li>
<li>File Trailer：用于检验页是否完整的部分，占用固定的8个字节。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 事务ACID</title>
    <url>/2020/09/02/Mysql-%E4%BA%8B%E5%8A%A1ACID/</url>
    <content><![CDATA[<h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><p>事务就是一个操作序列，要么这些操作全部执行，要么操作不执行，它是一个不可分割的工作单位。</p>
<span id="more"></span>
<h3 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h3><p>一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。</p>
<p>实现事务的原子性，数据库要支持回滚操作，在事务中某个操作失败后，回滚到事务之前的状态。</p>
<p>大多数数据库实现事务时，事务操作的数据是在事务相关的数据快照上，并不是真正修改实际的数据，如果有错不提交即可。</p>
<p>而其他一些只支持简单事务的数据库系统中，事务更新数据不在快照上，而是直接操作实际数据，则系统需要先预演一遍所有要执行的操作，如果失败，事务相关的所有操作都不会被执行。</p>
<h3 id="1-2-一致性"><a href="#1-2-一致性" class="headerlink" title="1.2 一致性"></a>1.2 一致性</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>如转账的栗子: 假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<p>事务的一致性决定了一个系统设计和实现的复杂度，因为事务可以有不同程度的一致性：</p>
<ul>
<li><p><strong>强一致性</strong>: 无论更新操作是在哪一个数据副本执行，之后所有的读操作都能获得最新的数据。</p>
</li>
<li><p><strong>弱一致性</strong>: 提交的更新操作，不一定立即会被读操作读到，需要一段时间，此种情况会存在一个不一致窗口。</p>
</li>
<li><p><strong>最终一致性</strong>: 是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等</p>
</li>
</ul>
<h3 id="1-3-隔离性"><a href="#1-3-隔离性" class="headerlink" title="1.3 隔离性"></a>1.3 隔离性</h3><p>隔离性是当多个用户并发访问数据库时，同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如操作同一张表，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<h3 id="1-4-持久性"><a href="#1-4-持久性" class="headerlink" title="1.4 持久性"></a>1.4 持久性</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<h2 id="2-并发一致性问题"><a href="#2-并发一致性问题" class="headerlink" title="2.并发一致性问题"></a>2.并发一致性问题</h2><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h3 id="2-1-丢失更新"><a href="#2-1-丢失更新" class="headerlink" title="2.1 丢失更新"></a>2.1 丢失更新</h3><p><img src="/images/pasted-79.png" class="lazyload" data-srcset="/images/pasted-79.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="2-2-脏读"><a href="#2-2-脏读" class="headerlink" title="2.2 脏读"></a>2.2 脏读</h3><p>T1修改了数据，但随后T1撤销了修改，T2读的是脏数据。</p>
<p><img src="/images/pasted-80.png" class="lazyload" data-srcset="/images/pasted-80.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="2-3-不可重复读"><a href="#2-3-不可重复读" class="headerlink" title="2.3 不可重复读"></a>2.3 不可重复读</h3><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和和第一次读取的结果不同。<br><img src="/images/pasted-81.png" class="lazyload" data-srcset="/images/pasted-81.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="2-4-幻读"><a href="#2-4-幻读" class="headerlink" title="2.4 幻读"></a>2.4 幻读</h3><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="/images/pasted-82.png" class="lazyload" data-srcset="/images/pasted-82.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="2-5-特点"><a href="#2-5-特点" class="headerlink" title="2.5 特点"></a>2.5 特点</h3><p>上述四种问题的特点：</p>
<p>丢失修改：T1，T2都进行修改提交，T1的更新会丢失</p>
<p>读脏数据：T1先修改  T2随后读取 ，T1再回滚，则T2读到了脏数据。</p>
<p>不可重复读：T2读 T1修改 T2再读</p>
<p>幻影读：T1读 T2修改 T1再读，</p>
<h3 id="2-6-区别"><a href="#2-6-区别" class="headerlink" title="2.6 区别"></a>2.6 区别</h3><p>从控制的角度来讲，不可重复读只需要锁住满足条件的记录，而幻影读要锁住满足条件的及其相近的记录。所以，避免幻读，必须锁住表，避免不可重复读，只需要锁住行。</p>
<p>不可重复读和幻读最大的区别在于，如何通过锁的机制来解决它们产生的问题。</p>
<p>可以采用悲观锁的机制来处理问题，悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。所以出于性能的考虑，成熟的数据库使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免上述两种问题。</p>
<p>乐观锁，大多是基于数据版本记录机制实现的。</p>
<p>1.SELECT  : 当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号。</p>
<p>2.INSERT : 将当前系统版本号作为数据行快照的创建版本号。</p>
<p>3.DELETE : 将当前系统版本号作为数据行快照的删除版本号。</p>
<p>4.UPDATE : 可以理解为先执行 DELETE 后执行 INSERT。</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/58534510">https://zhuanlan.zhihu.com/p/58534510</a><br><a href="https://www.cnblogs.com/drunkhero/p/strenghen-comprehension-on-dirty-read-and-phantom-of-mysql.html">https://www.cnblogs.com/drunkhero/p/strenghen-comprehension-on-dirty-read-and-phantom-of-mysql.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 当前读，快照读和MVCC</title>
    <url>/2020/09/03/Mysql-%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8CMVCC/</url>
    <content><![CDATA[<h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p><strong>当前读, 读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。</strong></p>
<span id="more"></span>
<p>具体有以下操作：</p>
<ul>
<li><code>select...lock in share mode</code> (共享读锁)</li>
<li><code>select...for update</code></li>
<li><code>update , delete , insert</code></li>
</ul>
<p>举例：</p>
<p>假设要<code>update</code>一条记录，但是另一个事务已经<code>delete</code>这条数据并且<code>commit</code>了，如果不加锁就会产生冲突。所以<code>update</code>的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。</p>
<h3 id="当前读的实现方式"><a href="#当前读的实现方式" class="headerlink" title="当前读的实现方式"></a>当前读的实现方式</h3><p>next-key锁(行记录锁 + Gap间隙锁)</p>
<h2 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h2><p>快照读 即：<code>snapshot read</code>，官方叫法是：<code>Consistent Nonlocking Reads</code>，即：一致性非锁定读.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这次查询 只能看到 别的事务 生成快照前提交的数据，</span><br><span class="line">而不能看到别的事务生成快照后提交的数据或者未提交的数据。</span><br></pre></td></tr></table></figure>

<p>单纯的<code>select</code>操作，不包括上述 <code>select ... lock in share mode, select ... for update</code>。　</p>
<ul>
<li><p><code>Read Committed</code>隔离级别：每次<code>select</code>都生成一个快照读</p>
</li>
<li><p><code>Read Repeatable</code>隔离级别：开启事务后第一个<code>select</code>语句才是快照读的地方，而不是一开启事务就快照读</p>
</li>
</ul>
<h3 id="快照读的实现方式"><a href="#快照读的实现方式" class="headerlink" title="快照读的实现方式"></a>快照读的实现方式</h3><p> undolog和多版本并发控制MVCC</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/16f272c02aac">https://www.jianshu.com/p/16f272c02aac</a><br><a href="https://zhuanlan.zhihu.com/p/55819387">https://zhuanlan.zhihu.com/p/55819387</a><br><a href="https://zhuanlan.zhihu.com/p/55872397">https://zhuanlan.zhihu.com/p/55872397</a><br><a href="https://www.jianshu.com/p/eb3f56565b42">https://www.jianshu.com/p/eb3f56565b42</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql InnoDB行格式</title>
    <url>/2020/09/03/Mysql-%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://learnku.com/articles/33781">https://learnku.com/articles/33781</a></p>
</blockquote>
<p>真实数据在不同存储引擎中存放的格式一般是不同的</p>
<p>InnoDB采取的方式是：<strong>将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。</strong></p>
<span id="more"></span>
<h2 id="0-InnoDB页简介"><a href="#0-InnoDB页简介" class="headerlink" title="0. InnoDB页简介"></a>0. InnoDB页简介</h2><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时，InnoDB存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死，InnoDB采取的方式是：<strong>将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。</strong>也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p>
<h3 id="0-1-InnoDB行格式"><a href="#0-1-InnoDB行格式" class="headerlink" title="0.1 InnoDB行格式"></a>0.1 InnoDB行格式</h3><p>我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。设计InnoDB存储引擎的大叔们到现在为止设计了4种不同类型的行格式，分别是Compact、Redundant、Dynamic和Compressed行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。</p>
<h4 id="指定行格式的语法"><a href="#指定行格式的语法" class="headerlink" title="指定行格式的语法"></a>指定行格式的语法</h4><p>我们可以在创建或修改表的语句中指定行格式：</p>
<p><code>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code><br><code>ALTER TABLE 表名 ROW_FORMAT=行格式名称</code></p>
<h2 id="1-COMPACT行格式"><a href="#1-COMPACT行格式" class="headerlink" title="1.COMPACT行格式"></a>1.COMPACT行格式</h2><p><img src="/images/pasted-84.png" class="lazyload" data-srcset="/images/pasted-84.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<!--more-->

<p><img src="/images/pasted-92.png" class="lazyload" data-srcset="/images/pasted-92.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！</p>
<p>如果该可变字段允许存储的最大字节数(MxW)(W值表示一个字符最多使用的字节数，M表示变长类型最多存储M个字符)超过255字节并且真实存储的字节数（L）超过127字节，则使用两个字节，否则使用一个字节。</p>
<p><img src="/images/pasted-83.png" class="lazyload" data-srcset="/images/pasted-83.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>小贴士： 并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有.</p>
<h3 id="1-1-NULL值列表"><a href="#1-1-NULL值列表" class="headerlink" title="1.1 NULL值列表"></a>1.1 NULL值列表</h3><p>1.统计语序存储NULL的列</p>
<p>2.如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：</p>
<ul>
<li>二进制位的值为1时，代表该列的值为NULL。</li>
<li>二进制位的值为0时，代表该列的值不为NULL</li>
</ul>
<p><img src="/images/pasted-85.png" class="lazyload" data-srcset="/images/pasted-85.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>3.MySQL规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。</p>
<p><img src="/images/pasted-86.png" class="lazyload" data-srcset="/images/pasted-86.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>对于第二条记录来说，c1、c3、c4这3个列中c3和c4的值都为NULL，所以这3个列对应的二进制位的情况就是：<br><img src="/images/pasted-93.png" class="lazyload" data-srcset="/images/pasted-93.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>110对应16进制为0x06</p>
<p>最终</p>
<p><img src="/images/pasted-94.png" class="lazyload" data-srcset="/images/pasted-94.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="1-2-记录头信息"><a href="#1-2-记录头信息" class="headerlink" title="1.2 记录头信息"></a>1.2 记录头信息</h3><p>除了变长字段长度列表、NULL值列表之外，还有一个用于描述记录的记录头信息，它是由固定的5个字节组成。5个字节也就是40个二进制位，不同的位代表不同的意思，如图：</p>
<p><img src="/images/pasted-88.png" class="lazyload" data-srcset="/images/pasted-88.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>二进制位代表详细信息：<br><img src="/images/pasted-87.png" class="lazyload" data-srcset="/images/pasted-87.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="1-3-记录的真实数据"><a href="#1-3-记录的真实数据" class="headerlink" title="1.3 记录的真实数据"></a>1.3 记录的真实数据</h3><p>除了自己定立的列的数据外，还有一些隐藏列</p>
<p><img src="/images/pasted-89.png" class="lazyload" data-srcset="/images/pasted-89.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>小贴士： 实际上这几个列的真正名称其实是：<code>DB_ROW_ID</code>、<code>DB_TRX_ID</code>、<code>DB_ROLL_PTR</code>，我们为了美观才写成了row_id、transaction_id和roll_pointer。</p>
<p><code>InnoDB表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique键作为主键，如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。</code></p>
<p>真实记录</p>
<p><img src="/images/pasted-90.png" class="lazyload" data-srcset="/images/pasted-90.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-91.png" class="lazyload" data-srcset="/images/pasted-91.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="1-4-CHAR-M-列的存储格式"><a href="#1-4-CHAR-M-列的存储格式" class="headerlink" title="1.4 CHAR(M)列的存储格式"></a>1.4 CHAR(M)列的存储格式</h3><p>逆序存储</p>
<p><img src="/images/pasted-95.png" class="lazyload" data-srcset="/images/pasted-95.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。</p>
<h2 id="2-Redundant行格式-mysql5-0之前的行格式"><a href="#2-Redundant行格式-mysql5-0之前的行格式" class="headerlink" title="2.Redundant行格式(mysql5.0之前的行格式)"></a>2.Redundant行格式(mysql5.0之前的行格式)</h2><p><img src="/images/pasted-96.png" class="lazyload" data-srcset="/images/pasted-96.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>![upload successful](/images/pasted-98.png）<br>偏移表示第几列就是偏移数组中两两相减差值，表示长度</p>
<p><img src="/images/pasted-99.png" class="lazyload" data-srcset="/images/pasted-99.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>记录头</p>
<p><img src="/images/pasted-97.png" class="lazyload" data-srcset="/images/pasted-97.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="2-1-char列存储格式"><a href="#2-1-char列存储格式" class="headerlink" title="2.1 char列存储格式"></a>2.1 char列存储格式</h3><p>占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和M的乘积。</p>
<h2 id="3-溢出数据"><a href="#3-溢出数据" class="headerlink" title="3.溢出数据"></a>3.溢出数据</h2><p>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些<br>页的地址（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页<br><img src="/images/pasted-100.png" class="lazyload" data-srcset="/images/pasted-100.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>从图中可以看出来，对于Compact和Reduntant行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做行溢出，存储超出768字节的那些页面也被称为溢出页。画一个简图就是这样：</p>
<h2 id="4-Dynamic和Compressed行格式"><a href="#4-Dynamic和Compressed行格式" class="headerlink" title="4.Dynamic和Compressed行格式"></a>4.Dynamic和Compressed行格式</h2><p>行格式和Compact挺像的，但是不会存储768个字节真实数据，直接存溢出页地址</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><ul>
<li>页是MySQL中磁盘和内存交互的基本单位，也是MySQL是管理存储空间的基本单位。</li>
<li>指定和修改行格式的语法如下：</li>
</ul>
<p><code>CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称</code></p>
<p><code>ALTER TABLE 表名 ROW_FORMAT=行格式名称</code></p>
<p>InnoDB目前定义了4种行格式</p>
<h3 id="5-1-COMPACT行格式"><a href="#5-1-COMPACT行格式" class="headerlink" title="5.1 COMPACT行格式"></a>5.1 COMPACT行格式</h3><p>具体组成如图：</p>
<p><img src="/images/pasted-101.png" class="lazyload" data-srcset="/images/pasted-101.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="5-2-Redundant"><a href="#5-2-Redundant" class="headerlink" title="5.2 Redundant"></a>5.2 Redundant</h3><p><img src="/images/pasted-102.png" class="lazyload" data-srcset="/images/pasted-102.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="5-3-Dynamic和Compressed"><a href="#5-3-Dynamic和Compressed" class="headerlink" title="5.3 Dynamic和Compressed"></a>5.3 Dynamic和Compressed</h3><p>类似于compact行格式，不会记录真实数据处存储字符床的钱768个字节，而是把所有字节都存储到其他页面中，实际地址存储存储页面的地址。<br>Compressed行格式会采用压缩算法堆页面进行压缩</p>
<p>一个页一般是16KB，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为行溢出。</p>
]]></content>
  </entry>
  <entry>
    <title>Mysql建立索引的常用规则</title>
    <url>/2020/09/25/Mysql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<ul>
<li>1、表的主键、外键必须有索引；</li>
<li>2、数据量超过300的表应该有索引；</li>
<li>3、经常与其他表进行连接的表，在连接字段上应该建立索引；</li>
<li>4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>5、索引应该建在选择性高的字段上；</li>
<li>6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；</li>
<li>7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 隔离级别</title>
    <url>/2020/09/03/Mysql%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySql 事务隔离级别和允许并发副作用，分别如下表：</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th align="left">脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read uncommitted）</td>
<td align="left">是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读（read committed）</td>
<td align="left">否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable read）</td>
<td align="left">否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td align="left">否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<span id="more"></span>

<p>由上表可知，MySQL 共支持四种事务隔离级别。表由上到下允许并发副作用越来越弱，似乎我们只要选择串行化（serializable）的事务隔离级别就不会发生脏读、不可重复读、幻读等问题了，但是选择串行化（serializable）却会带来一定的性能下降。所以关于如何选择事务隔离级别我们需要对脏读、不可重复读、幻读有一定认知，并确定这几种副作用对应用的影响，然后选择合适的隔离级别。</p>
<p>MySQL 的默认事务隔离级别为 <code>可重复读（repeatable read）</code> 所以我们不用担心<code>「脏读」</code>和<code>「不可重复读」</code>。</p>
<p>可以设置默认隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别为 read committed，仅在本次会话中生效</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read committed;</span><br></pre></td></tr></table></figure>
<p>或者修改配置文件<code>my.cnf</code>配置文件使其永久生效。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">transaction-isolation</span> = REPEATABLE-READ</span><br></pre></td></tr></table></figure>








<blockquote>
<p>作者：一只贱熊猫<br>链接：<a href="https://juejin.im/post/6844903681196982285">https://juejin.im/post/6844903681196982285</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/6844903681196982285">https://juejin.im/post/6844903681196982285</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI网络模型</title>
    <url>/2020/07/01/OSI%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="/images/pasted-30.png" class="lazyload" data-srcset="/images/pasted-30.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><pre><code>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</code></pre><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><pre><code>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</code></pre><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><pre><code>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</code></pre><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><pre><code>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</code></pre><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><pre><code>本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</code></pre><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><pre><code>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。

数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。

MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</code></pre><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><pre><code>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</code></pre>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>OSI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3 requests 编码错误</title>
    <url>/2020/06/08/Python3-requests-%E7%BC%96%E7%A0%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>报错代码</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response = requests.post(base_url, headers=&#123;&quot;Content-Type&quot;:&quot;application/ndjson&quot;&#125;, data=data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<span id="more"></span>

<p>报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/PycharmProjects/Afenci/insert.py&quot;</span>, line <span class="number">18</span>, <span class="keyword">in</span> begin_insert_job</span><br><span class="line">    bulk_insert(base_url, line)</span><br><span class="line">  File <span class="string">&quot;E:/PycharmProjects/Afenci/insert.py&quot;</span>, line <span class="number">9</span>, <span class="keyword">in</span> bulk_insert</span><br><span class="line">    response = requests.post(base_url, headers=&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/ndjson&quot;</span>&#125;, data=data)</span><br><span class="line">  File <span class="string">&quot;E:\PycharmProjects\Afenci\venvforwindows\lib\site-packages\requests\api.py&quot;</span>, line <span class="number">119</span>, <span class="keyword">in</span> post</span><br><span class="line">    <span class="keyword">return</span> request(<span class="string">&#x27;post&#x27;</span>, url, data=data, json=json, **kwargs)</span><br><span class="line">  File <span class="string">&quot;E:\PycharmProjects\Afenci\venvforwindows\lib\site-packages\requests\api.py&quot;</span>, line <span class="number">61</span>, <span class="keyword">in</span> request</span><br><span class="line">    <span class="keyword">return</span> session.request(method=method, url=url, **kwargs)</span><br><span class="line">  File <span class="string">&quot;E:\PycharmProjects\Afenci\venvforwindows\lib\site-packages\requests\sessions.py&quot;</span>, line <span class="number">530</span>, <span class="keyword">in</span> request</span><br><span class="line">    resp = self.send(prep, **send_kwargs)</span><br><span class="line">  File <span class="string">&quot;E:\PycharmProjects\Afenci\venvforwindows\lib\site-packages\requests\sessions.py&quot;</span>, line <span class="number">643</span>, <span class="keyword">in</span> send</span><br><span class="line">    r = adapter.send(request, **kwargs)</span><br><span class="line">  File <span class="string">&quot;E:\PycharmProjects\Afenci\venvforwindows\lib\site-packages\requests\adapters.py&quot;</span>, line <span class="number">449</span>, <span class="keyword">in</span> send</span><br><span class="line">    timeout=timeout</span><br><span class="line">  File <span class="string">&quot;E:\PycharmProjects\Afenci\venvforwindows\lib\site-packages\urllib3\connectionpool.py&quot;</span>, line <span class="number">677</span>, <span class="keyword">in</span> urlopen</span><br><span class="line">    chunked=chunked,</span><br><span class="line">  File <span class="string">&quot;E:\PycharmProjects\Afenci\venvforwindows\lib\site-packages\urllib3\connectionpool.py&quot;</span>, line <span class="number">392</span>, <span class="keyword">in</span> _make_request</span><br><span class="line">    conn.request(method, url, **httplib_request_kw)</span><br><span class="line">  File <span class="string">&quot;C:\Users\wujinfa\AppData\Local\Programs\Python\Python36\lib\http\client.py&quot;</span>, line <span class="number">1239</span>, <span class="keyword">in</span> request</span><br><span class="line">    self._send_request(method, url, body, headers, encode_chunked)</span><br><span class="line">  File <span class="string">&quot;C:\Users\wujinfa\AppData\Local\Programs\Python\Python36\lib\http\client.py&quot;</span>, line <span class="number">1284</span>, <span class="keyword">in</span> _send_request</span><br><span class="line">    body = _encode(body, <span class="string">&#x27;body&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;C:\Users\wujinfa\AppData\Local\Programs\Python\Python36\lib\http\client.py&quot;</span>, line <span class="number">161</span>, <span class="keyword">in</span> _encode</span><br><span class="line">    (name.title(), data[err.start:err.end], name)) <span class="keyword">from</span> <span class="literal">None</span></span><br><span class="line">UnicodeEncodeError: <span class="string">&#x27;latin-1&#x27;</span> codec can<span class="string">&#x27;t encode characters in position 36-38: Body (&#x27;</span>陈秉忠<span class="string">&#x27;) is not valid Latin-1. Use body.encode(&#x27;</span>utf-<span class="number">8</span><span class="string">&#x27;) if you want to send it encoded in UTF-8.</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>(1)python3换python2</p>
<p>或者</p>
<p>(2)utf-8 格式http client源码有问题,不支持中文，需要转换编码方式</p>
<p><code>data = line.encode(&quot;utf-8&quot;).decode(&quot;latin1&quot;)</code></p>
<blockquote>
<p><a href="https://blog.csdn.net/Hepburn_li/article/details/90379062">https://blog.csdn.net/Hepburn_li/article/details/90379062</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>Small points</title>
    <url>/2020/09/20/Small-points/</url>
    <content><![CDATA[<p>这篇博客用于记录学习过程中的一些small points，包括计算机网络，操作系统，数据结构，算法，Java语言等</p>
<span id="more"></span>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是面向对象的一块基石，继承就是子类继承父类的行为和特征，使得子类对象具有父类的实例域和方法，或者从父类继承方法，使得子类具有和父类相同的行为。</p>
<h3 id="重写与重载："><a href="#重写与重载：" class="headerlink" title="重写与重载："></a>重写与重载：</h3><p>重写返回值和形参都不变，外壳不变，核心重写，重载是一个类里方法名字相同，参数不同，返回值也可以不同。每个重载的方法都必须要有一个独一无二的参数列表。</p>
<table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h3 id="一次完整的http请求"><a href="#一次完整的http请求" class="headerlink" title="一次完整的http请求"></a>一次完整的http请求</h3><p><img src="/images/pasted-127.png" class="lazyload" data-srcset="/images/pasted-127.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-128.png" class="lazyload" data-srcset="/images/pasted-128.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="链路层："><a href="#链路层：" class="headerlink" title="链路层："></a>链路层：</h3><p>以太网规定一组电信号就是一个数据包，一个数据包被称为一帧， 制定这个规则的协议就是以太网协议，以太网数据包：</p>
<p><img src="/images/pasted-129.png" class="lazyload" data-srcset="/images/pasted-129.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<blockquote>
<p><a href="https://www.cnblogs.com/onepixel/p/7092302.html">https://www.cnblogs.com/onepixel/p/7092302.html</a></p>
</blockquote>
<h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><p> 递归查询，浏览器缓存-本地缓存-ISP提供商-根域名服务器</p>
<p> 迭代查询： 根域名-顶级域名-二级域名</p>
<h3 id="给一个数字，判断是否是回文数字"><a href="#给一个数字，判断是否是回文数字" class="headerlink" title="给一个数字，判断是否是回文数字"></a>给一个数字，判断是否是回文数字</h3><p>并且需要考虑转换后是否越界问题，数字正负数都有可能（时间复杂度小于O(n)，并且不能借助数组或转为字符串的方式）?  </p>
<p> 方法：使用栈，分奇数偶数</p>
<p> 求出每一位的数字，再还原一下和原来数字比较</p>
<h3 id="什么是内存泄漏："><a href="#什么是内存泄漏：" class="headerlink" title="什么是内存泄漏："></a>什么是内存泄漏：</h3><p>1.对象未被引用</p>
<p>2.垃圾回收器无法回收，因为还被引用着。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">v = <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<ul>
<li>8.常见的内存泄漏： 1.static修饰的静态集合类</li>
</ul>
<p> 2.单例模式 3.监听器 4. 各种连接 5.内部类和外部模块的引用</p>
<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p><img src="/images/pasted-130.png" class="lazyload" data-srcset="/images/pasted-130.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。<br><img src="/images/pasted-131.png" class="lazyload" data-srcset="/images/pasted-131.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>反向代理服务器一般用作负载均衡 （负载均衡（Cloud Load Balancer，CLB）提供安全快捷的流量分发服务，访问流量经由 CLB 可以自动分配到云中的多台云服务器上，扩展系统的服务能力并消除单点故障。负载均衡支持亿级连接和千万级并发，可轻松应对大流量访问，满足业务需求。）</p>
<h3 id="双亲委派机制的工作流程"><a href="#双亲委派机制的工作流程" class="headerlink" title="双亲委派机制的工作流程;"></a>双亲委派机制的工作流程;</h3><p>1.当前classloader从已加载的类中查询此类是否已加载，如果已加载，则直接返回已加载的类</p>
<p>2.没有找到时，委托父类加载器加载，依次递归，父类加载器可以完成加载任务时，就成功返回</p>
<p>3.所有父类加载器没有加载的时候，由当前类加载器加载</p>
<h3 id="类的加载机制"><a href="#类的加载机制" class="headerlink" title="类的加载机制"></a>类的加载机制</h3><p>加载 - 验证 - 准备 - 解析 - 初始化 - 使用 - 卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 装载：查找和导入Class文件；</span><br><span class="line"></span><br><span class="line">(2) 链接：把类的二进制数据合并到JRE中；</span><br><span class="line"></span><br><span class="line">   (a)校验：检查载入Class文件数据的正确性；</span><br><span class="line"></span><br><span class="line">   (b)准备：给类的静态变量分配存储空间；</span><br><span class="line"></span><br><span class="line">   (c)解析：将符号引用转成直接引用；</span><br><span class="line"></span><br><span class="line">(3) 初始化：对类的静态变量，静态代码块执行初始化操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>准备阶段; 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p>
<p>（1）类的实例变量会在对象实例化时随着对象一起分配在Java堆中。</p>
<p>（2）这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<blockquote>
<p><a href="https://juejin.im/post/6844903564804882445">https://juejin.im/post/6844903564804882445</a></p>
</blockquote>
<p>解析阶段:在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p>
<h3 id="成员变量和局部变量："><a href="#成员变量和局部变量：" class="headerlink" title="成员变量和局部变量："></a>成员变量和局部变量：</h3><p>成员变量随着对象的建立而建立，随着对象的消失而消失，存在对象所在的堆内存中。</p>
<p>局部变量存在栈内存中。</p>
<h3 id="成员变量和静态变量的区别"><a href="#成员变量和静态变量的区别" class="headerlink" title="成员变量和静态变量的区别"></a>成员变量和静态变量的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、两个变量的生命周期不同</span><br><span class="line"></span><br><span class="line">       成员变量随着对象的创建而存在，随着对象被回收而释放。</span><br><span class="line"></span><br><span class="line">       静态变量随着类的加载而存在，随着类的消失而消失。</span><br><span class="line"></span><br><span class="line"> 2、调用方式不同</span><br><span class="line"></span><br><span class="line">       成员变量只能被对象调用。</span><br><span class="line"></span><br><span class="line">       静态变量可以被对象调用，还可以被类名调用。</span><br><span class="line"></span><br><span class="line"> 3、别名不同</span><br><span class="line"></span><br><span class="line">       成员变量也称为实例变量。</span><br><span class="line"></span><br><span class="line">       静态变量也称为类变量。</span><br><span class="line"></span><br><span class="line"> 4、数据存储位置不同</span><br><span class="line"></span><br><span class="line">       成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</span><br><span class="line"></span><br><span class="line">       静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Map下面的实现类"><a href="#Map下面的实现类" class="headerlink" title="Map下面的实现类:"></a>Map下面的实现类:</h3><p>HashMap,Hashtable,LinkedHashMap,TreeMap</p>
<h3 id="线程的三种创建方法："><a href="#线程的三种创建方法：" class="headerlink" title="线程的三种创建方法："></a>线程的三种创建方法：</h3><p><img src="/images/pasted-132.png" class="lazyload" data-srcset="/images/pasted-132.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="线程同步的四种方式："><a href="#线程同步的四种方式：" class="headerlink" title="线程同步的四种方式："></a>线程同步的四种方式：</h3><p>临界区（Critical Section）、互斥对象（Mutex）：主要用于互斥控制；都具有拥有权的控制方法，只有拥有该对象的线程才能执行任务，所以拥有，执行完任务后一定要释放该对象。</p>
<p>信号量（Semaphore）、事件对象（Event）：事件对象是以通知的方式进行控制，主要用于同步控制！</p>
<h3 id="linux下统计文件行数：-wc-l"><a href="#linux下统计文件行数：-wc-l" class="headerlink" title="linux下统计文件行数： wc -l"></a>linux下统计文件行数： wc -l</h3><h3 id="ArrayList初始容量10，扩容时扩容1-5倍"><a href="#ArrayList初始容量10，扩容时扩容1-5倍" class="headerlink" title="ArrayList初始容量10，扩容时扩容1.5倍"></a>ArrayList初始容量10，扩容时扩容1.5倍</h3><h3 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h3><p>多态指同一个行为具有不同的表现形式或形态的能力。</p>
<p>多态存在的三个必要条件： 1.继承 2.重写 3.父类引用指向子类对象。</p>
<p>多态实现方式：（1）重写 （2）接口 （3）抽象类和抽象方法</p>
<h3 id="索引失效："><a href="#索引失效：" class="headerlink" title="索引失效："></a>索引失效：</h3><p>单列索引：</p>
<p>1.查询条件使用了不等式 <code>&lt;&gt;</code> 或<code>!=</code></p>
<p>2.查询条件的类型不一致，例如查String字段输入了数字</p>
<p>3.使用函数计算</p>
<p>4.模糊查询</p>
<p>联合索引：</p>
<p>（1）查询条件使用不等式</p>
<p>（2）查询条件类型不一致</p>
<p>（3）查询条件使用函数计算</p>
<p>（4）不适用索引首列当查询条件</p>
<h3 id="本地方法栈、虚拟机栈"><a href="#本地方法栈、虚拟机栈" class="headerlink" title="本地方法栈、虚拟机栈"></a>本地方法栈、虚拟机栈</h3><p>Native Method 就是一个java调用非Java代码的接口。</p>
<p>本地方法栈和Java虚拟机栈实现的功能类似,只不过本地方法区是本地方法运行的内存模型.本地方法被执行的时候,在本地方法栈也会创建一个栈帧,用于存放该本地方法的局部变量表\操作数栈\动态链接\出口信息.</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间.也会抛出OutOfMemoryError和StackOverflowError异常.</p>
<p>有一些虚拟机（如HotSpot）将java虚拟机栈和本地方法栈合并实现。</p>
<p><strong>虚拟机栈</strong><br>java虚拟机栈和程序计数器一样，他是线程私有的内存区域，他的生命周期与线程相同，java虚拟机栈描述的是java方法执行时候的内存概念模型，每个方法在执行的时候都会创建一个栈帧，用来创建这个方法的操作数栈，局部变量表，方法出口，动态链接等信息，每一个方法在调用和结束的过程就对应了一个栈帧在虚拟机栈中入栈到出栈的过程，</p>
<p>java虚拟机栈是一个后进先出栈，靠后执行的方法会优先完成，后面进入虚拟机栈的栈帧优先被出栈，这与我们平时执行java方法的印象是一致的，在程序执行中java方法的调用，执行和退出，都与java虚拟机栈里面存储的栈帧有着密切的联系。</p>
<h3 id="OSI网络模型表示层"><a href="#OSI网络模型表示层" class="headerlink" title="OSI网络模型表示层"></a>OSI网络模型表示层</h3><p>表示层：数据压缩、加密以及数据描述，使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>链路层地址，长度未6字节（48位），用于唯一标识网络适配器（网卡）。</p>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<h3 id="交换机和路由器"><a href="#交换机和路由器" class="headerlink" title="交换机和路由器"></a>交换机和路由器</h3><p><strong>工作层次不同</strong>：<br>交换机主要工作在数据链路层（第二层）</p>
<p>路由器工作在网络层（第三层）。</p>
<p><strong>转发依据不同</strong>：<br>交换机转发所依据的对象是：MAC地址。（物理地址）</p>
<p>路由转发所依据的对象是：IP地址。（网络地址）</p>
<p><strong>主要功能不同</strong>：<br>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。交换机能做的，路由都能做。</p>
<p>交换机不能分割广播域，路由可以。路由还可以提供防火墙的功能。路由配置比交换机复杂。</p>
<p>交换机带宽是网络带宽，而路由器则是共享带宽。</p>
<p>交换机是单独拨号，路由器是使用同一个账号。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p><a href="https://blog.csdn.net/txy534989700/article/details/51557204">https://blog.csdn.net/txy534989700/article/details/51557204</a></p>
<h3 id="为什么用了Synchronized还要用cas"><a href="#为什么用了Synchronized还要用cas" class="headerlink" title="为什么用了Synchronized还要用cas"></a>为什么用了Synchronized还要用cas</h3><p>一开始数组上是null的时候使用CAS进行put而不需要加锁，如果成功了就成功了，如果失败了再使用synchronized</p>
]]></content>
      <categories>
        <category>Small points</category>
      </categories>
      <tags>
        <tag>points</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IoC AOP</title>
    <url>/2020/09/08/Spring-IoC-AOP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 框架相关术语</title>
    <url>/2020/09/07/Spring-%E6%A1%86%E6%9E%B6%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="Spring是什么？"><a href="#Spring是什么？" class="headerlink" title="Spring是什么？"></a>Spring是什么？</h2><p>Spring是一个开发应用框架，有以下几个特点：<font color = red>轻量级、非侵入式、一站式、模块化</font>。</p>
<span id="more"></span>

<p>应用程序开发：</p>
<ol>
<li>除了要开发业务逻辑外，</li>
<li>还要关注对象写作来完成所需功能</li>
<li>低耦合，高内聚</li>
</ol>
<h2 id="Spring带来了什么"><a href="#Spring带来了什么" class="headerlink" title="Spring带来了什么"></a>Spring带来了什么</h2><p>简化开发</p>
<ol>
<li>帮助我们根据配置文件创建以及组装对象之间的依赖关系</li>
<li>面向切向变成能够帮助我们无耦合的实现</li>
<li>帮我们管理数据库事务</li>
<li>提供第三方数据访问框架（Hibernate, JPA)无缝集成，自己也提供了一套JDBC访问模板</li>
<li>还提供第三方Web框架无缝集成，自己也提供了一套SpringMVC框架</li>
<li>能够方便与java EE整合， 与更多技术整合</li>
</ol>
<h2 id="Spring相关术语"><a href="#Spring相关术语" class="headerlink" title="Spring相关术语"></a>Spring相关术语</h2><p><strong>应用程序</strong>：<br>是我们完成功能的成品，比如购物网站，OA系统(办公自动化系统),ERP系统（企业资源计划系统）等。</p>
<p><strong>框架</strong>：<br>完成一定功能的半成品，框架规定了开发时的整体架构，实现了基础功能，规定了类和对象如何创建，如何协作等从而简化开发。</p>
<p><strong>非侵入式设计</strong>：<br>无需继承框架提供的类，就可以看作是非侵入式设计，如果继承了框架类则是侵入式设计，以后更换框架之前写的代码就无法重用，非侵入式则可以重用。</p>
<p><strong>轻量级和重量级</strong>：<br>轻量级一般就是非侵入式的，所依赖东西少，资源占用少，部署简单等，重量级相反</p>
<p><strong>POJO</strong>：<br>Plain Old Java Objects 简单的Java对象，它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色不继承或不实现任何其他框架的类或接口</p>
<p><strong>容器</strong>：<br>装对象的容器，因为存在放入，拿出操作，容器还要管理对象的生命周期</p>
<p><strong>控制反转</strong>：<br>Inversion of Control 缩写IoC， 控制反转还有一个名字叫做依赖注入（Dependency Ijection) 就是容器控制程序之间的关系，而非传统实现中，由程序代码直接操控</p>
<p><strong>bean</strong>：<br>一般指容器管理对象，在Spring中指Spring IoC容器管理对象</p>
<h2 id="Spring的好处"><a href="#Spring的好处" class="headerlink" title="Spring的好处"></a>Spring的好处</h2><p><strong>非常轻量级的容器</strong>：以集中的、自动化的方式进行应用程序对象创建和装配，负责对象创建和装配，管理对象生命周期，能组合成复杂的应用程序。Spring容器是非侵入式的（不需要依赖任何Spring特定类），而且完全采用POJOs进行开发，使应用程序更容易测试、更容易管理。而且核心JAR包非常小，Spring3.0.5不到1M，而且不需要依赖任何应用服务器，可以部署在任何环境（Java SE或Java EE）。</p>
<p><strong>AOP</strong>：AOP是Aspect Oriented Programming的缩写，意思是面向切面编程，提供从另一个角度来考虑程序结构以完善面向对象编程（相对于OOP），即可以通过在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能的一种技术。通俗点说就是把可重用的功能提取出来，然后将这些通用功能在合适的时候织入到应用程序中；比如安全，日记记录，这些都是通用的功能，我们可以把它们提取出来，然后在程序执行的合适地方织入这些代码并执行它们，从而完成需要的功能并复用了这些功能。</p>
<p><strong>简单的数据库事务管理</strong>：在使用数据库的应用程序当中，自己管理数据库事务是一项很让人头疼的事，而且很容易出现错误，Spring支持可插入的事务管理支持，而且无需JEE环境支持，通过Spring管理事务可以把我们从事务管理中解放出来来专注业务逻辑。</p>
<p><strong>JDBC抽象及ORM框架支持</strong>：Spring使JDBC更加容易使用；提供DAO（数据访问对象）支持，非常方便集成第三方ORM框架，比如Hibernate等；并且完全支持Spring事务和使用Spring提供的一致的异常体系。</p>
<p><strong>灵活的Web层支持</strong>：Spring本身提供一套非常强大的MVC框架，而且可以非常容易的与第三方MVC框架集成，比如Struts等。</p>
<p><strong>简化各种技术集成</strong>：提供对Java Mail、任务调度、JMX、JMS、JNDI、EJB、动态语言、远程访问、Web Service等的集成。</p>
<h2 id="Spring结构图"><a href="#Spring结构图" class="headerlink" title="Spring结构图"></a>Spring结构图</h2><p><img src="/images/pasted-123.png" class="lazyload" data-srcset="/images/pasted-123.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="Spring应用场景"><a href="#Spring应用场景" class="headerlink" title="Spring应用场景"></a>Spring应用场景</h2><h3 id="典型Web应用程序应用场景"><a href="#典型Web应用程序应用场景" class="headerlink" title="典型Web应用程序应用场景"></a>典型Web应用程序应用场景</h3><p><img src="/images/pasted-124.png" class="lazyload" data-srcset="/images/pasted-124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>Spring的声明式事务管理功能让web应用程序完全是事务性的,就像如果你使用EJB容器管理的事务。你所有的自定义的业务逻辑可以通过简单的pojo实现和由Spring的IoC容器。服务包括支持发送电子邮件和web层的独立验证,可以让你选择在哪里执行验证规则。</p>
<h3 id="远程访问应用场景"><a href="#远程访问应用场景" class="headerlink" title="远程访问应用场景"></a>远程访问应用场景</h3><p><img src="/images/pasted-125.png" class="lazyload" data-srcset="/images/pasted-125.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>Spring能非常方便的提供暴露RMI服务，远程访问服务如Hessian、Burlap等，实现非常简单只需通过在Spring中配置相应的地址及需要暴露的服务即可轻松实现。</p>
<blockquote>
<p>作者：斜杠Allen<br>链接：<a href="https://www.jianshu.com/p/7b6a070119c7">https://www.jianshu.com/p/7b6a070119c7</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 注解</title>
    <url>/2020/09/08/Spring-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Sql调优</title>
    <url>/2020/09/26/Sql/</url>
    <content><![CDATA[<p>sql调优的目的是减少查询时间，主要操作目的是：减少磁盘IO操作进而减少查询时间。</p>
<span id="more"></span>

<h3 id="建索引"><a href="#建索引" class="headerlink" title="建索引"></a>建索引</h3><ol>
<li><p>在where及order by 涉及的列上建立索引</p>
</li>
<li><p>在需要的字段上进行检索</p>
</li>
<li><p>一个表的索引数最好不超过6个，建太多降低插入和update的效率</p>
</li>
</ol>
<blockquote>
<p><a href="http://233hsysweb.ml/2020/09/25/Mysql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/">http://233hsysweb.ml/2020/09/25/Mysql%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B8%B8%E7%94%A8%E8%A7%84%E5%88%99/</a></p>
</blockquote>
<h3 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h3><p>避免使用计算</p>
<p>具体见前面</p>
<blockquote>
<p><a href="http://233hsysweb.ml/2020/09/20/Small-points/">http://233hsysweb.ml/2020/09/20/Small-points/</a></p>
</blockquote>
<h3 id="使用预编译查询"><a href="#使用预编译查询" class="headerlink" title="使用预编译查询"></a>使用预编译查询</h3><pre><code>程序中通常是根据用户的输入来动态执行SQL，这时应该尽量使用参数化SQL,这样不仅可以避免SQL注入漏洞攻击，最重要数据库会对这些参数化SQL进行预编译，这样第一次执行的时候DBMS会为这个SQL语句进行查询优化并且执行预编译，这样以后再执行这个SQL的时候就直接使用预编译的结果，这样可以大大提高执行的速度。</code></pre><h3 id="调整where子句中的连接顺序"><a href="#调整where子句中的连接顺序" class="headerlink" title="调整where子句中的连接顺序"></a>调整where子句中的连接顺序</h3><p>表连接最好写在其他where条件之前</p>
<h3 id="多条sql压缩到一句"><a href="#多条sql压缩到一句" class="headerlink" title="多条sql压缩到一句"></a>多条sql压缩到一句</h3><p>每次执行SQL的时候都要建立网络连接、进行权限校验、进行SQL语句的查询优化、发送执行结果，这个过程是非常耗时的，因此应该尽量避免过多的执行SQL语句，能够压缩到一句SQL执行的语句就不要用多条来执行</p>
<h3 id="where字句替换HAVING"><a href="#where字句替换HAVING" class="headerlink" title="where字句替换HAVING"></a>where字句替换HAVING</h3><p> 避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数 的过滤，除此之外，应该将条件写在where字句中。</p>
<h3 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h3><p>多表连接时，减少解析时间，减少歧义</p>
<h3 id="union-all替换union"><a href="#union-all替换union" class="headerlink" title="union all替换union"></a>union all替换union</h3><p>union 会进行合并和排序，如果可以判断检索结果中不会有重复记录时，应该用union all，这样不用排序</p>
<h3 id="使用临时表暂存中间结果"><a href="#使用临时表暂存中间结果" class="headerlink" title="使用临时表暂存中间结果"></a>使用临时表暂存中间结果</h3><p>将临时结果暂存在临时表，后面的查询就在tempdb中了，这可以避免程序中多次扫描主表，也大大减少了程序执行中“共享锁”阻塞“更新锁”，减少了阻塞，提高了并发性能。<br>但是也得避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
<h3 id="只要在必要的情况下才使用事务"><a href="#只要在必要的情况下才使用事务" class="headerlink" title="只要在必要的情况下才使用事务"></a>只要在必要的情况下才使用事务</h3><h3 id="使用varchar-nvarchar代替char-ncahr"><a href="#使用varchar-nvarchar代替char-ncahr" class="headerlink" title="使用varchar/nvarchar代替char/ncahr"></a>使用varchar/nvarchar代替char/ncahr</h3><p>变长字段替代定长字段</p>
<h3 id="查询select语句优化"><a href="#查询select语句优化" class="headerlink" title="查询select语句优化"></a>查询select语句优化</h3><p><img src="/images/pasted-137.png" class="lazyload" data-srcset="/images/pasted-137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<blockquote>
<p><a href="https://www.cnblogs.com/dc-earl/p/10837577.html">https://www.cnblogs.com/dc-earl/p/10837577.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>String,StringBuffer与StringBuilder的区别</title>
    <url>/2020/07/23/String-StringBuffer%E4%B8%8EStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="/images/pasted-57.png" class="lazyload" data-srcset="/images/pasted-57.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<table>
<thead>
<tr>
<th></th>
<th>特点</th>
<th>是否可变</th>
<th>线程安全</th>
</tr>
</thead>
<tbody><tr>
<td>String</td>
<td>String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间</td>
<td>不可变</td>
<td>—</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量</td>
<td>可变</td>
<td>线程不安全，单线程操作字符串</td>
</tr>
<tr>
<td>StringBuffer</td>
<td>可变类，速度更快</td>
<td>可变</td>
<td>线程安全，可以多线程操作字符串</td>
</tr>
</tbody></table>
<h3 id="Java-String"><a href="#Java-String" class="headerlink" title="Java String"></a>Java String</h3><pre><code>简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，这样不仅效率低下，而且大量浪费有限的内存空间，所以经常改变内容的字符串最好不要用 String 。因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。</code></pre><p><img src="/images/pasted-56.png" class="lazyload" data-srcset="/images/pasted-56.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><p>当对字符串进行修改的时候，特别是字符串对象经常改变的情况下，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>与 String 类不同的是，<strong>StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</strong></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>（1）如果要操作少量的数据用 String；</p>
<p>（2）多线程操作字符串缓冲区下操作大量数据 StringBuffer；</p>
<p>（3）单线程操作字符串缓冲区下操作大量数据 StringBuilder。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h5 id="String常量与String变量的”-”操作比较"><a href="#String常量与String变量的”-”操作比较" class="headerlink" title="String常量与String变量的”+”操作比较"></a>String常量与String变量的”+”操作比较</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">str</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">       String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">       <span class="keyword">long</span> beginTime = System.currentTimeMillis();  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            str = <span class="string">&quot;Heart&quot;</span> + <span class="string">&quot;Raid&quot;</span>;</span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">long</span> endTime = System.currentTimeMillis();  </span><br><span class="line">       System.out.println(endTime - beginTime); </span><br><span class="line">       </span><br><span class="line">       String s1 = <span class="string">&quot;Heart&quot;</span>;</span><br><span class="line">       String s2 = <span class="string">&quot;Raid&quot;</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> beginTime1 = System.currentTimeMillis();  </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000000</span>;i++)&#123;</span><br><span class="line">            str = s1 + s2;</span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">long</span> endTime1=System.currentTimeMillis();  </span><br><span class="line">       System.out.println(endTime1 - beginTime1); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-58.png" class="lazyload" data-srcset="/images/pasted-58.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>结果: String常量的连接 稍优于String变量的连接</p>
<p>原因：</p>
<p>测试一中， <code>&quot;Heart&quot; + &quot;Raid&quot;</code>在编译阶段就已经连接起来，形成了一个字符串常量，并指向队中的拘留字符对象。运行时，只需要将<code>&quot;HeartRaid&quot;</code>指向的字符串对象地址取出100W次，存放在局部变量str中。</p>
<p>测试二中，局部变量s1，s2存放的是不同字符串对象的地址，然后会通过下列三个步骤完成 <code>+</code>连接：</p>
<ol>
<li>StringBuilder temp = new StringBuilder(s1);</li>
<li>temp.append(s2);</li>
<li>str = temp.toString();</li>
</ol>
<p>我们发现，虽然在中间的时候也用到了append()方法，但是在开始和结束的时候分别创建了StringBuilder和String对象。可想而知：调用1W次，是不是就创建了100W次这两种对象呢？不划算。</p>
<h4 id="String对象的”累-”连接操作与StringBuffer对象的append-累和连接操作比较"><a href="#String对象的”累-”连接操作与StringBuffer对象的append-累和连接操作比较" class="headerlink" title="String对象的”累+”连接操作与StringBuffer对象的append()累和连接操作比较"></a>String对象的”累+”连接操作与StringBuffer对象的append()累和连接操作比较</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">str</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">     String s1 = <span class="string">&quot;Heart&quot;</span> ;</span><br><span class="line">     String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">     <span class="keyword">long</span> beginTime = System.currentTimeMillis();  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">          s= s + s1;</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">long</span> endTime = System.currentTimeMillis();  </span><br><span class="line">     System.out.println(endTime - beginTime); </span><br><span class="line">     </span><br><span class="line">     String s2 = <span class="string">&quot;Heart&quot;</span>;</span><br><span class="line">     StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> beginTime1 = System.currentTimeMillis();  </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;</span><br><span class="line">          sb.append(s2);</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">long</span> endTime1=System.currentTimeMillis();  </span><br><span class="line">     System.out.println(endTime1 - beginTime1); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-59.png" class="lazyload" data-srcset="/images/pasted-59.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>结果：后者远小于前者</p>
<p>原因：</p>
<p>测试① 中的s=s+s1，JVM会利用首先创建一个StringBuilder，并利用append方法完成s和s1所指向的字符串对象值的合并操作，接着调用StringBuilder的 toString()方法在堆中创建一个新的String对象，其值为刚才字符串的合并结果。而局部变量s指向了新创建的String对象。</p>
<ol>
<li><p>StringBuilder temp = new StringBuilder(s);</p>
</li>
<li><p>temp.append(s1);</p>
</li>
<li><p>s = temp.toString();</p>
<p>因为String对象中的value[]是不能改变的，每一次合并后字符串值都需要创建一个新的String对象来存放。循环1W次自然需要创建1W个String对象和1W个StringBuilder对象，效率低就可想而知了。</p>
</li>
</ol>
<p>测试②中sb.append(s1);只需要将自己的value[]数组不停的扩大来存放s2即可。循环过程中无需在堆中创建任何新的对象。效率高就不足为奇了.</p>
<h3 id="String与StringBuilder的相互转换"><a href="#String与StringBuilder的相互转换" class="headerlink" title="String与StringBuilder的相互转换"></a>String与StringBuilder的相互转换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">String s=<span class="string">&quot;hellowork&quot;</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);<span class="comment">//使用构造方法转换</span></span><br><span class="line">System.out.println(s);</span><br><span class="line">System.out.println(sb);</span><br><span class="line"></span><br><span class="line">StringBuilder sbb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sbb.append(<span class="string">&quot;hello&quot;</span>).append(<span class="string">&quot;work&quot;</span>);</span><br><span class="line">String ss = sb.toString();<span class="comment">//使用toString方法转换</span></span><br><span class="line">System.out.println(sbb);</span><br><span class="line">System.out.println(ss);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="StringBuilder实现数组元素按格式实现拼接"><a href="#StringBuilder实现数组元素按格式实现拼接" class="headerlink" title="StringBuilder实现数组元素按格式实现拼接"></a>StringBuilder实现数组元素按格式实现拼接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span>[] arr = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">      sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">      <span class="comment">//遍历数组</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">              sb.append(arr[i]);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              sb.append(arr[i]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">      String s = sb.toString();</span><br><span class="line">      System.out.println(s);</span><br></pre></td></tr></table></figure>


<blockquote>
<p><a href="https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303">https://blog.csdn.net/itchuxuezhe_yang/article/details/89966303</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 三次握手四次挥手</title>
    <url>/2020/07/01/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/images/pasted-25.png" class="lazyload" data-srcset="/images/pasted-25.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<p>tcp的6种标志位的分别代表：</p>
<p>SYN(synchronous建立联机)</p>
<p>ACK(acknowledgement 确认)</p>
<p>PSH(push传送)</p>
<p>FIN(finish结束)</p>
<p>RST(reset重置)</p>
<p>URG(urgent紧急)</p>
<p>Sequence number(顺序号码)</p>
<p>Acknowledge number(确认号码)</p>
<p>握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：</p>
<p>（1）首先客户端向服务器端发送一段TCP报文，其中：</p>
<ul>
<li>标记位为SYN，表示“请求建立新连接”;</li>
<li>序号为Seq=X（X一般为1）；</li>
<li>随后客户端进入SYN-SENT阶段。</li>
</ul>
<p>（2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：</p>
<ul>
<li>标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；</li>
<li>序号为Seq=y；</li>
<li>确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；随后服务器端进入SYN-RCVD阶段。</li>
</ul>
<p>（3）客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：</p>
<p>标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；<br>序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；<br>确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；<br>随后客户端进入ESTABLISHED阶段。<br>服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。</p>
<p>在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续”握手”，以此确保了”三次握手”的顺利完成。</p>
<p>此后客户端和服务器端进行正常的数据传输。这就是“三次握手”的过程。</p>
<p><img src="https://pic.rmb.bdstatic.com/861fa058f2da35f8efa70b29bf7c45fd8689.gif" class="lazyload" data-srcset="https://pic.rmb.bdstatic.com/861fa058f2da35f8efa70b29bf7c45fd8689.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="动态过程"></p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/images/pasted-28.png" class="lazyload" data-srcset="/images/pasted-28.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>为什么客户端最后还要等待2MSL？<br>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，<strong>站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次</strong>，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使<strong>本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</strong></p>
<p><img src="/images/pasted-29.png" class="lazyload" data-srcset="/images/pasted-29.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2020/08/31/TCP/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw">https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw</a><br><img src="/images/pasted-70.png" class="lazyload" data-srcset="/images/pasted-70.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
</blockquote>
<span id="more"></span>
<h2 id="什么是TCP？"><a href="#什么是TCP？" class="headerlink" title="什么是TCP？"></a>什么是TCP？</h2><p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p><img src="/images/pasted-71.png" class="lazyload" data-srcset="/images/pasted-71.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="OSI参考模型与TCP/IP的关系"><br>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。</p>
<p>因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</p>
<h3 id="TCP的定义和特点"><a href="#TCP的定义和特点" class="headerlink" title="TCP的定义和特点"></a>TCP的定义和特点</h3><p>TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p><img src="/images/pasted-72.png" class="lazyload" data-srcset="/images/pasted-72.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<ul>
<li><p>面向连接：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p>
</li>
<li><p>可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p>
</li>
<li><p>字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</p>
</li>
</ul>
<h3 id="什么是连接"><a href="#什么是连接" class="headerlink" title="什么是连接"></a>什么是连接</h3><p><img src="/images/pasted-73.png" class="lazyload" data-srcset="/images/pasted-73.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>简单来说就是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</p>
<p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。</p>
<ul>
<li><p>Socket：由 IP 地址和端口号组成</p>
</li>
<li><p>序列号：用来解决乱序问题等</p>
</li>
<li><p>窗口大小：用来做流量控制</p>
</li>
</ul>
<h3 id="确定唯一一个TCP连接"><a href="#确定唯一一个TCP连接" class="headerlink" title="确定唯一一个TCP连接"></a>确定唯一一个TCP连接</h3><p>TCP四元组<br><img src="/images/pasted-74.png" class="lazyload" data-srcset="/images/pasted-74.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p>
<p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p>
<h3 id="最大连接数"><a href="#最大连接数" class="headerlink" title="最大连接数"></a>最大连接数</h3><p><img src="/images/pasted-75.png" class="lazyload" data-srcset="/images/pasted-75.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="TCP头部格式"><a href="#TCP头部格式" class="headerlink" title="TCP头部格式"></a>TCP头部格式</h2><p>头部由20个字节组成：</p>
<ol>
<li>源端口号2字节16位，目标端口号2字节16位</li>
<li>序列号4字节32位</li>
<li>确认应答号4字节32位</li>
<li>首部长度4位(数据偏移位数)</li>
<li>保留位6位</li>
<li>窗口大小2字节16位</li>
<li>检验和2字节16位</li>
<li>紧急指针2字节16位</li>
<li>可变长度选项</li>
<li>数据</li>
</ol>
<p>序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题</strong>。</p>
<p>确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题</strong>。</p>
<p><strong>控制位</strong>：</p>
<ul>
<li><p>ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。</p>
</li>
<li><p>RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</p>
</li>
<li><p>SYN：该位为 1 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。</p>
</li>
<li><p>FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位置为 1 的 TCP 段。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP为什么要三次握手和四次挥手</title>
    <url>/2020/08/31/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h3 id="为什么三次握手"><a href="#为什么三次握手" class="headerlink" title="为什么三次握手"></a>为什么三次握手</h3><p><strong>一次握手的情况：</strong></p>
<p>   由于TCP是面向连接的，一次很明显时不可能的，因为客户端发出连接消息后，却没有接收到来自服务端的回应，客户端就无法确定服务端接是否收到了连接请求，当然也就不能确定是否连接成功。<br> <span id="more"></span>  </p>
<p><img src="/images/pasted-69.png" class="lazyload" data-srcset="/images/pasted-69.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="两次握手"><a href="#两次握手" class="headerlink" title="两次握手"></a>两次握手</h3><p>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</p>
<p>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>接下来以三个方面分析三次握手的原因：</p>
<ul>
<li><p>三次握手才可以阻止历史重复连接的初始化（主要原因）</p>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
</li>
<li><p>三次握手才可以避免资源浪费</p>
</li>
</ul>
<p>三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。</p>
<p><img src="/images/pasted-76.png" class="lazyload" data-srcset="/images/pasted-76.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw">https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw</a><br><a href="https://blog.csdn.net/Shuffle_Ts/article/details/93778635">https://blog.csdn.net/Shuffle_Ts/article/details/93778635</a><br><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>TP-link的面经</title>
    <url>/2020/06/28/TP-link%E7%9A%84%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<ol>
<li>个人介绍—–简历、个人技能、个人简介不熟悉</li>
<li>专业问题—为何找软开</li>
<li>java学习时间多久，如何学习的</li>
<li>项目中印象比较深刻的一个问题</li>
<li>volatile synchronized</li>
<li>项目介绍—实验室项目</li>
<li>spring boot框架</li>
<li>项目中用到了哪些spring知识</li>
<li>强引用、软引用、弱引用    垃圾回收情况</li>
<li>一直留在成都</li>
<li>兴趣爱好</li>
<li>有什么问题：现在用的最多的java框架是什么</li>
<li>java拦截器，过滤器</li>
<li>最近在学习的技术</li>
</ol>
<!---more--->
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>ThreadLocal是什么？</title>
    <url>/2020/08/28/ThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="/images/pasted-66.png" class="lazyload" data-srcset="/images/pasted-66.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<p>jdk1.8文档介绍</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This class provides thread-local variables.  These variables differ from</span></span><br><span class="line"><span class="comment"> * their normal counterparts in that each thread that accesses one (via its</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> get&#125; or &#123;<span class="doctag">@code</span> set&#125; method) has its own, independently initialized</span></span><br><span class="line"><span class="comment"> * copy of the variable.  &#123;<span class="doctag">@code</span> ThreadLocal&#125; instances are typically private</span></span><br><span class="line"><span class="comment"> * static fields in classes that wish to associate state with a thread (e.g.,</span></span><br><span class="line"><span class="comment"> * a user ID or Transaction ID).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For example, the class below generates unique identifiers local to each</span></span><br><span class="line"><span class="comment"> * thread.</span></span><br><span class="line"><span class="comment"> * A thread&#x27;s id is assigned the first time it invokes &#123;<span class="doctag">@code</span> ThreadId.get()&#125;</span></span><br><span class="line"><span class="comment"> * and remains unchanged on subsequent calls.</span></span><br><span class="line"><span class="comment"> */</span>  	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>ThreadLocal提供了线程的局部变量，每个线程都可以通过<code>set()</code>和<code>get()</code>来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离的。</p>
<p>简要言之：往ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。</p>
<h3 id="ThreadLocal原理总结"><a href="#ThreadLocal原理总结" class="headerlink" title="ThreadLocal原理总结"></a>ThreadLocal原理总结</h3><p>ThreadLocal设计的目的就是为了能够在当前线程中有属于自己的变量，并不是为了解决并发或者共享变量的问题。</p>
<ol>
<li>每个Thread维护着一个ThreadLocalMap的引用</li>
<li>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</li>
<li>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象</li>
<li>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象</li>
<li>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</li>
<li>ThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；</li>
<li>ThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</li>
<li>使用ThreadLocal要用try … finally结构，并在finally中清除。</li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p><img src="/images/pasted-66.png" class="lazyload" data-srcset="/images/pasted-66.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p>
<blockquote>
<p><a href="https://juejin.im/post/6844903586984361992">https://juejin.im/post/6844903586984361992</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode java build error</title>
    <url>/2020/08/28/Vscode-java-build-error/</url>
    <content><![CDATA[<p><img src="/images/pasted-64.png" class="lazyload" data-srcset="/images/pasted-64.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>
<p>vscode java maven项目 build出错，</p>
<p><code>Build failed,do you want to contine? Source:Debugger for java (Extension)</code></p>
<h3 id="按下面博客说的，删除workspaceStorage文件夹，没有成功，"><a href="#按下面博客说的，删除workspaceStorage文件夹，没有成功，" class="headerlink" title="按下面博客说的，删除workspaceStorage文件夹，没有成功，"></a>按下面博客说的，删除workspaceStorage文件夹，没有成功，</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_28632639/article/details/100764746">https://blog.csdn.net/qq_28632639/article/details/100764746</a></p>
</blockquote>
<h3 id="清理-vscode文件夹-也未成功"><a href="#清理-vscode文件夹-也未成功" class="headerlink" title="清理 .vscode文件夹 也未成功"></a>清理 .vscode文件夹 也未成功</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_45662289/article/details/104084386">https://blog.csdn.net/qq_45662289/article/details/104084386</a></p>
</blockquote>
<h3 id="查看-language-support-for-java-插件输出"><a href="#查看-language-support-for-java-插件输出" class="headerlink" title="查看 language support for java 插件输出"></a>查看 language support for java 插件输出</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_32384249/article/details/101446882">https://blog.csdn.net/qq_32384249/article/details/101446882</a></p>
</blockquote>
<p><img src="/images/pasted-65.png" class="lazyload" data-srcset="/images/pasted-65.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Error - 上午10:33:06] 2020-8-28 10:33:06 Error occured while building workspace. Details: </span><br><span class="line"> message: Cannot instantiate the type Account; code: 16777373; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 10</span><br><span class="line"> message: Cannot instantiate the type Account; code: 16777373; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 11</span><br><span class="line"> message: The method transfer(Account, int) is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 14</span><br><span class="line"> message: The method transfer(Account, int) is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 19</span><br><span class="line"> message: The method getMoney() is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 28</span><br><span class="line"> message: The method getMoney() is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 28</span><br><span class="line"> message: The type Account is already defined; code: 16777539; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 40</span><br><span class="line">[Error - 上午10:36:07] 2020-8-28 10:36:07 Error occured while building workspace. Details: </span><br><span class="line"> message: Cannot instantiate the type Account; code: 16777373; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 10</span><br><span class="line"> message: Cannot instantiate the type Account; code: 16777373; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 11</span><br><span class="line"> message: The method transfer(Account, int) is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 14</span><br><span class="line"> message: The method transfer(Account, int) is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 19</span><br><span class="line"> message: The method getMoney() is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 28</span><br><span class="line"> message: The method getMoney() is undefined for the type Account; code: 67108964; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 28</span><br><span class="line"> message: The type Account is already defined; code: 16777539; resource: E:/Avscode/erchashu/ys/src/main/java/hs/bf/ExerciseTransfer.java; line: 40</span><br></pre></td></tr></table></figure>
<p>把出错的class注释掉，错误解决了。</p>
]]></content>
      <categories>
        <category>Vscode</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode+wsl2下c/c++ 环境配置配置</title>
    <url>/2021/06/07/Vscode-wsl2%E4%B8%8Bc-c-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>微软官方wsl下C/C++环境配置</p>
<p><a href="https://code.visualstudio.com/docs/editor/variables-reference">https://code.visualstudio.com/docs/editor/variables-reference</a></p>
<span id="more"></span>

<p>调试时出现错误:</p>
<p><img src="/images/pasted-144.png" class="lazyload" data-srcset="/images/pasted-144.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">无法打开“libc-start.c”: 无法读取文件&#x27;vscode-remote://wsl+ubuntu-20.04/build/glibc-eX1tMB/glibc-2.31/csu/libc-start.c&#x27; (Error: 无法解析不存在的文件&quot;vscode-remote://wsl+ubuntu-20.04/build/glibc-eX1tMB/glibc-2.31/csu/libc-start.c&quot;)。</span><br></pre></td></tr></table></figure>
<p>解决办法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">huanshi2@DESKTOP-VRNCVPP:/$ cd build/</span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:/build$ mkdir glibc-eX1tMB</span><br><span class="line">mkdir: cannot create directory ‘glibc-eX1tMB’: Permission denied</span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:/build$ sudo mkdir glibc-eX1tMB</span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:/build$ cd glibc-eX1tMB/</span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:/build/glibc-eX1tMB$ sudo wget http://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gz </span><br><span class="line">--2021-06-07 15:11:43--  http://ftp.gnu.org/gnu/glibc/glibc-2.31.tar.gz</span><br><span class="line">Resolving ftp.gnu.org (ftp.gnu.org)... 209.51.188.20, 2001:470:142:3::b</span><br><span class="line">Connecting to ftp.gnu.org (ftp.gnu.org)|209.51.188.20|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 32648590 (31M) [application/x-gzip]</span><br><span class="line">Saving to: ‘glibc-2.31.tar.gz’</span><br><span class="line"></span><br><span class="line">glibc-2.31.tar.gz     100%[========================&gt;]  31.14M  58.0KB/s    in 6m 56s  </span><br><span class="line"></span><br><span class="line">2021-06-07 15:18:40 (76.6 KB/s) - ‘glibc-2.31.tar.gz’ saved [32648590/32648590]</span><br><span class="line"></span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:/build/glibc-eX1tMB$ sudo tar -zxvf glibc-2.31.tar.gz</span><br></pre></td></tr></table></figure>
<p>成功解决：</p>
<p><img src="/images/pasted-145.png" class="lazyload" data-srcset="/images/pasted-145.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>待解决</p>
<p>调试还会出现某个文件中头文件标红的情况</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>copyonwrite</title>
    <url>/2020/08/30/copyonwrite/</url>
    <content><![CDATA[<h2 id="copy-on-write思想"><a href="#copy-on-write思想" class="headerlink" title="copy-on-write思想"></a>copy-on-write思想</h2><p>写入时复制思想是计算机程序设计中的一种通用优化策略。</p>
<p>核心思想是如果有多个调用者同时访问相同的资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者修改资源内容时，系统会复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初资源仍然保持不变。</p>
<span id="more"></span>

<p>通俗易懂的讲，写入时复制技术就是不同进程在访问同一资源的时候，只有更新操作，才会去复制一份新的数据并更新替换，否则都是访问同一个资源。</p>
<h3 id="JDK中的COW"><a href="#JDK中的COW" class="headerlink" title="JDK中的COW"></a>JDK中的COW</h3><p>JDK 的<code>CopyOnWriteArrayList/CopyOnWriteArraySet</code> 容器正是采用了 COW 思想，它是如何工作的呢？</p>
<p>简单来说，就是平时查询的时候，都不需要加锁，随便访问，只有在更新的时候，才会从原来的数据复制一个副本出来，然后修改这个副本，最后把原数据替换成当前的副本。修改操作的同时，读操作不会被阻塞，而是继续读取旧的数据。这点要跟读写锁区分一下。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>对于一些读多写少的数据，写入时复制的做法就很不错，例如配置、黑名单、物流地址等变化非常少的数据，这是一种无锁的实现。可以帮我们实现程序更高的并发。</p>
<p>CopyOnWriteArrayList 并发安全且性能比 Vector 好。Vector 是增删改查方法都加了synchronized 来保证同步，但是每个方法执行的时候都要去获得锁，性能就会大大下降，而 CopyOnWriteArrayList 只是在增删改上加锁，但是读不加锁，在读方面的性能就好于 Vector。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>数据一致性问题。这种实现只是保证数据的最终一致性，在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。</p>
<p>内存占用问题。如果对象比较大，频繁地进行替换会消耗内存，从而引发 Java 的 GC 问题，这个时候，我们应该考虑其他的容器，例如 ConcurrentHashMap。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/jmcui/p/12377081.html">https://www.cnblogs.com/jmcui/p/12377081.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言学习</title>
    <url>/2021/07/25/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>c语言学习计划</p>
<p>TODO</p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>freeze_support error</title>
    <url>/2020/06/05/freeze-support-error/</url>
    <content><![CDATA[<p>python3 error</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RuntimeError: </span><br><span class="line">        An attempt has been made to start a new process before the</span><br><span class="line">        current process has finished its bootstrapping phase.</span><br><span class="line"></span><br><span class="line">        This probably means that you are <span class="keyword">not</span> using fork to start your</span><br><span class="line">        child processes <span class="keyword">and</span> you have forgotten to use the proper idiom</span><br><span class="line">        <span class="keyword">in</span> the main module:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">                freeze_support()</span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">        The <span class="string">&quot;freeze_support()&quot;</span> line can be omitted <span class="keyword">if</span> the program</span><br><span class="line">        <span class="keyword">is</span> <span class="keyword">not</span> going to be frozen to produce an executable.</span><br></pre></td></tr></table></figure>

<p>加个<code>if __name__ == &#39;__main__&#39;:</code>就好了</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo deploy error</title>
    <url>/2020/07/21/git/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stderr:</span><br><span class="line">   &#x27;(node:364) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</span><br><span class="line">   (node:375) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.</span><br><span class="line">   fatal: could not parse HEAD</span><br><span class="line">   error: refs/heads/master does not point to a valid object!</span><br><span class="line">   Everything up-to-date&#x27;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>解决办法：</p>
<blockquote>
<p>　<a href="https://blog.csdn.net/zhanglongtumi/article/details/73526750">https://blog.csdn.net/zhanglongtumi/article/details/73526750</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:~/blog/.deploy_git$ find .git/objects/ -type f -empty | xargs rm</span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:~/blog/.deploy_git$ git fetch -p</span><br><span class="line">error: refs/heads/master does not point to a valid object!</span><br><span class="line">error: refs/heads/master does not point to a valid object!</span><br><span class="line">error: refs/heads/master does not point to a valid object!</span><br><span class="line">error: refs/heads/master does not point to a valid object!</span><br><span class="line">remote: Enumerating objects: 6409, done.</span><br><span class="line">remote: Counting objects: 100% (6409/6409), done.</span><br><span class="line">remote: Compressing objects: 100% (1253/1253), done.</span><br><span class="line">remote: Total 10576 (delta 2905), reused 6150 (delta 2650), pack-reused 4167</span><br><span class="line">Receiving objects: 100% (10576/10576), 10.82 MiB | 390.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (4649/4649), done.</span><br><span class="line">From https://github.com/huanshi2/huanshi2.github.io</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:~/blog/.deploy_git$ git fsck --full</span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (18161/18161), done.</span><br><span class="line">dangling blob 3381364de58f04eee8efdcd30af72a69702199d5</span><br><span class="line">dangling blob 030483548db5960c2212abc0af641f48db038dc0</span><br><span class="line">dangling blob a904fde6f7c927d15b2621530fed5ebac9d8ad60</span><br><span class="line">dangling blob 0c86d895e8272f0cfff0bf21c63c8410a3804c96</span><br><span class="line">dangling blob b808656ad298f56ada6658f51702b6feabb5fb55</span><br><span class="line">dangling blob 4989d8388f4e1799a873314dd9c3ee6a0e613099</span><br><span class="line">dangling blob f08bccfd8fcefb9752240bb1a31ecbb23ee5752a</span><br><span class="line">dangling blob 3390f4fd72597398fc9aa140a86b190f51367591</span><br><span class="line">dangling blob e99081c449c6a8e093beccb0535b0393864a8861</span><br><span class="line">dangling blob b592baf9c11a44efd0434ab724036fde98956a56</span><br><span class="line">dangling blob bf9258fb107fa9462fcce6e2363470deda4dae76</span><br><span class="line">dangling blob 5f9316ae6eb270a710b2feaddd1f3ec8b4d463c4</span><br><span class="line">dangling blob b2941486da94983f94ca42c5a5099b34964cf352</span><br><span class="line">dangling blob dd168ec0d93e60ebd3563f6ec53914b6df0c3681</span><br><span class="line">dangling blob 051c9c84edd6b337da118150d393f02394764c25</span><br><span class="line">dangling blob 4b1de08449a50165e1a7cac2487cee90f6279faf</span><br><span class="line">dangling blob 731dcf9d8a101c2d0e043fe491ca083a9cce69bc</span><br><span class="line">dangling blob 7f1ea8b321f836c6cf0e7fc656b5eb46e782bc2d</span><br><span class="line">dangling blob 3d9f7abd5d228fdb5e97e260b3edb68ab80c9c1b</span><br><span class="line">dangling blob 1da1cf2679ddddf9234b93919afda39896c76a3d</span><br><span class="line">dangling blob 38229c9e986452722cc2a667ed6b85a6781a9832</span><br><span class="line">dangling blob bda3d39f23a1c039cd5cee805752d5311500998d</span><br><span class="line">dangling blob 5fa42d503a809489df1cf8407a7c9f92f01ba9a7</span><br><span class="line">dangling blob 592645a1c1401012f28b170cd7720171ca143f5e</span><br><span class="line">dangling blob 0fa7e5beccecb8db54a6d96b2f0b88780e3663d7</span><br><span class="line">dangling blob cca7f396dabd3ebe736fec335542e9a6090229d8</span><br><span class="line">dangling blob 14284d502960cc9e8814a82396ef9af9ce65670d</span><br><span class="line">dangling blob d8282cc7f54655590878f776ed93e61f8143079a</span><br><span class="line">dangling blob 9929f503947570d62ef93a9553c82535775f64b9</span><br><span class="line">dangling blob 7eaa914a50f374cd0b30ce7be9ab9d3c9707fffc</span><br><span class="line">dangling blob 0a2d7d2fea6459cc2dad75044376ab5afee8aabc</span><br><span class="line">dangling blob 232f8143da057257432380955994c05f10dde9e9</span><br><span class="line">dangling blob d3af790a4071216ec90ac6c4912e7cc9773bcf3e</span><br><span class="line">dangling blob efaf9624667fe4977a56e7601109a3f75d2d2883</span><br><span class="line">dangling blob 5db1d9aa77b1392476d68d655fb7f63210dd319f</span><br><span class="line">dangling blob 4132533838e439232692d170d19512b31a5a5254</span><br><span class="line">dangling blob ddb462cce81d38add00d1473964e8bded0545413</span><br><span class="line">dangling blob f8b5ec7dd7d172d286649d448fd81e5ac941825e</span><br><span class="line">dangling blob 37b7e127238cadcdb2b92f6c5581efd2cfff10df</span><br><span class="line">dangling blob e3376b5f67013570c0a303e557a0dba53c0dca67</span><br><span class="line">dangling blob 78b9dc85d2627dbc8ba49c63340762313e607595</span><br><span class="line">dangling blob 1c3ac378aace3752a460daf7eddcec9169a8fb1d</span><br><span class="line">dangling blob 1b3e140e26701cf7a68c693af853b54b03c835a7</span><br><span class="line">dangling blob 23c044e13b5194bb67e4b3dc9dbf38b23115d1f4</span><br><span class="line">dangling blob ebc06f1ee861693af3bef4d3884851759a78ea01</span><br><span class="line">dangling blob 37c14b8c37966e3641003abd599861308604088f</span><br><span class="line">dangling blob 59448b0659d2894e65163207c1b1ebe69c80fdb7</span><br><span class="line">dangling blob 9944907e68668b048c6020dd92a04fd999db8bf7</span><br><span class="line">dangling blob cdc7712ff784553d19e1cd81256dd15f609fdada</span><br><span class="line">dangling blob 50c8942217bddb43ccf6b6115b6969952d237962</span><br><span class="line">dangling blob 73cb66667d38e723a8de9a08342e8ed626ec886f</span><br><span class="line">dangling blob d54ba0a21499b037aabb044c9603322c916d71d5</span><br><span class="line">dangling blob 9dcc98edb385e042a3a3e29a687d9a78c80b8bd6</span><br><span class="line">dangling blob 16ceae81ff6bcc778d9260ea336896b84fc4f9e7</span><br><span class="line">dangling blob 97ced8c5d6176befb45a982abfc24dc24d4a1600</span><br><span class="line">dangling blob fcce1fd61dbc37bab08af3aa8b0fe77a98c74be8</span><br><span class="line">dangling blob 74d166e4b62015c64762335f9b9216d161c438c7</span><br><span class="line">dangling blob 8751dfb8b4130468940e9ec01f82937d42d3e888</span><br><span class="line">dangling blob 7bd2ff3d8e3e1135aacc7dd26d74d3081dddd402</span><br><span class="line">dangling blob 3d54d53bce11472ad43b09a354d7a609ab1d047d</span><br><span class="line">dangling blob c154833f9a03a24b55c8f944ddb33b8a792ee2cf</span><br><span class="line">dangling blob c4d542ad8503fcb0d460db66a949bc1aa6c9fc4f</span><br><span class="line">dangling blob 38d6967ed70c6a4c416eaa7425f45bdf2f928e48</span><br><span class="line">dangling blob 9656700f7ff12a9e6990f2737a465efd08dfc9b3</span><br><span class="line">dangling blob 5f57d74498dd2b3ec1432fda19016722dbe05e42</span><br><span class="line">dangling blob 68d761a245c0aa7b7f0c71d9c36f2c28e4e6fc52</span><br><span class="line">dangling blob 17d9a0703e41341421890a1632b977ee7950924a</span><br><span class="line">dangling blob df59668b1936e943a2cba4f8adaaf0a483750b4e</span><br><span class="line">dangling blob d4db40a3c7f0cd1233ba44c48a3e7c1d50f7ec8e</span><br><span class="line">dangling blob 4bdd5eb6e5fd878d2a746ecd3bc1c828f7d28fc3</span><br><span class="line">dangling blob d05f50a3f8c94a33a299a69d3d5f6b3477176b1c</span><br><span class="line">dangling blob 3060ce815b8194104d3ff1012bc751ad1dffb87e</span><br><span class="line">dangling blob 716119f982e40e374ee39d1402c22f5cc023fe9b</span><br><span class="line">dangling blob ef62995ec442331fe88d76179f82be6f5141dcb1</span><br><span class="line">dangling blob 3ee55b384fe968605a7bfd4fa75c884bb75b3376</span><br><span class="line">dangling tree 4665a28689fcea2f5663c714c042a3610384e19c</span><br><span class="line">dangling blob b165ac008489376dcece29176294f7de293a9fa1</span><br><span class="line">dangling blob 2ee6ffdd33a6bd9b405e43952e81ea9bd67cd060</span><br><span class="line">dangling blob bfe7cac6d898e81751c1bd4eb69234653673da4e</span><br><span class="line">dangling blob 026ba8c4e00010085729507af74647f1b2f9d87e</span><br><span class="line">dangling blob 5a6b30393fe44e82c921c7b2606322551bbe8032</span><br><span class="line">dangling blob 746b4cb7759fc08ffa8cdc6eb98767774c7399bc</span><br><span class="line">dangling blob 866b28c16658b8bba5b0b8f53edf8e7dc6f63e22</span><br><span class="line">dangling blob 29eca3420125525f0e4b3cd9da0b09ca3f5c5df3</span><br><span class="line">dangling blob c56c1a8e6c465a361d64aa7c06458b690b120c39</span><br><span class="line">dangling blob dc6efe7bace09250472e0076bacf87688cf6c5e6</span><br><span class="line">dangling blob eeee5f53403fca1b72776479cef409eaa91e5d90</span><br><span class="line">dangling blob 35712c388fbaf4a505ef9b739f82723b46a3e8b7</span><br><span class="line">dangling blob aaf4aa57f0d407e368e243024d4c043e45a9fbcb</span><br><span class="line">dangling blob 36f5b440134341d05a9de3c7128739bb1c3a6993</span><br><span class="line">dangling blob 7cf54d997e2c4dc0b08b3d17a24c34478549b786</span><br><span class="line">dangling tree 287670f0709127055cf12b31bafb9d98be3beca0</span><br><span class="line">dangling blob 5df7b68440951570b608cc1199d46a92f9c31d2e</span><br><span class="line">dangling blob 06faa38425d252d958f27de0facd0613ceff4f9a</span><br><span class="line">dangling blob 387a9e1083c0d71b8786384bed9c55d987d7d56e</span><br><span class="line">dangling blob 4ffa81f46ffaad83b66fa07bf2b31a92accbbcae</span><br><span class="line">dangling blob 49fc39a18f4aa1e7ea5a4cd8acdb6f927174f2b3</span><br><span class="line">dangling blob f9fd49e5ac59d67c91048cf446a90e86bfe8de33</span><br><span class="line">huanshi2@DESKTOP-VRNCVPP:~/blog/.deploy_git$ git checkout .</span><br><span class="line">Updated 1 path from the index</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Error</tag>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>java vector </title>
    <url>/2020/06/28/java-vector/</url>
    <content><![CDATA[<p>Vector 可实现自动增长的对象数组。<br>java.util.vector提供了向量类(Vector)以实现类似动态数组的功能。<br>创建了一个向量类的对象后，可以往其中随意插入不同类的对象，即不需顾及类型也不需预先选定向量的容量，并可以方便地进行查找。</p>
<p>对于预先不知或者不愿预先定义数组大小，并且需要频繁地进行查找，插入，删除工作的情况，可以考虑使用向量类。</p>
<span id="more"></span>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector v1 = <span class="keyword">new</span> Vector(); </span><br><span class="line">Integer integer1 = <span class="keyword">new</span> Integer(<span class="number">1</span>); </span><br><span class="line">v1.addElement(integer1); </span><br></pre></td></tr></table></figure>


















<blockquote>
<p><a href="https://www.cnblogs.com/zheting/p/7708366.html">https://www.cnblogs.com/zheting/p/7708366.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>java 动态代理</title>
    <url>/2020/06/28/java-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/9bcac608c714">https://www.jianshu.com/p/9bcac608c714</a></p>
</blockquote>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><blockquote>
<p><a href="https://www.jianshu.com/p/9bcac608c714">https://www.jianshu.com/p/9bcac608c714</a></p>
</blockquote>
<p>动态代理具体步骤：</p>
<ol>
<li><p>通过实现 InvocationHandler 接口创建自己的调用处理器；</p>
</li>
<li><p>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</p>
</li>
<li><p>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</p>
</li>
<li><p>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</p>
</li>
</ol>
<p>还有一种通过CgLIb代码生成库来进行</p>
<span id="more"></span>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>  为其他对象提供一个代理以控制对某个对象的访问。代理类主要负责为委托了（真实对象）预处理消息、过滤消息、传递消息给委托类，代理类不现实具体服务，而是利用委托类来完成服务，并将执行结果封装处理。</p>
<p>  其实就是代理类为被代理类预处理消息、过滤消息并在此之后将消息转发给被代理类，之后还能进行消息的后置处理。代理类和被代理类通常会存在关联关系(即上面提到的持有的被带离对象的引用)，代理类本身不实现服务，而是通过调用被代理类中的方法来提供服务。</p>
<p>(类比代理服务器转发消息)</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>
<p>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">HelloInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello zhanghao!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProxy</span> <span class="keyword">implements</span> <span class="title">HelloInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HelloInterface helloInterface = <span class="keyword">new</span> Hello();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke sayHello&quot;</span> );</span><br><span class="line">        helloInterface.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke sayHello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代理类调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloProxy helloProxy = <span class="keyword">new</span> HelloProxy();</span><br><span class="line">        helloProxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">Before invoke sayHello</span><br><span class="line">Hello zhanghao!</span><br><span class="line">After invoke sayHello</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<p>使用静态代理很容易就完成了对一个类的代理操作。但是静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐。</p>
<h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><p>利用反射机制在运行时创建代理类。<br>接口、被代理类不变，我们构建一个handler类来实现InvocationHandler接口。</p>
<p>在ProxyGenerator.generateProxyClass函数中 saveGeneratedFiles定义如下，其指代是否保存生成的代理类class文件，默认false不保存。</p>
<p>在前面的示例中，我们修改了此系统变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperties().setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">HelloInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello zhanghao!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before invoke &quot;</span>  + method.getName());</span><br><span class="line">        method.invoke(object, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;After invoke &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行动态代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入键值对，JDK动态代理生成的class文件保存到本地</span></span><br><span class="line">    System.getProperties().setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申明被代理类</span></span><br><span class="line">    HelloInterface hello = <span class="keyword">new</span> Hello();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代理handler</span></span><br><span class="line">    <span class="comment">//传入hello类参数</span></span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> ProxyHandler(hello);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代理类</span></span><br><span class="line">    <span class="comment">//newProxyInstance，方法有三个参数：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//loader: 用哪个类加载器去加载代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//interfaces:动态代理类需要实现的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//h:动态代理方法在执行时，会调用h里面的invoke方法去执行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入hello类加载器，接口，还有产生的代理handler</span></span><br><span class="line">    HelloInterface proxyHello = (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用invoke方法执行sayhello()方法</span></span><br><span class="line">    <span class="comment">//invoke 方法在Proxyhandler 中进行了重写</span></span><br><span class="line">    <span class="comment">//最终</span></span><br><span class="line">    proxyHello.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="/images/pasted-23.png" class="lazyload" data-srcset="/images/pasted-23.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="动态代理流程图"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>java 虚拟机栈</title>
    <url>/2020/07/01/java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/newAndHui/p/11168791.html">https://www.cnblogs.com/newAndHui/p/11168791.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>java优先队列</title>
    <url>/2020/07/22/java%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>实际上是一个堆，不指定Comparator时默认为最小堆。也可以根据Comparator来设置大根堆还是小根堆。</p>
<p>默认情况下，队列的头是按照指定排序方式的最小元素。如果多个元素都是最小值，则头是其中一个。</p>
<p>新建对象时可以指定初始容量，有自动扩容机制。</p>
<span id="more"></span>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>注意1：该队列是用数组实现，但是数组大小可以动态增加，容量无限。</p>
</li>
<li><p>注意2：队列的实现不是同步的。不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问 PriorityQueue实例。保证线程安全可以使用PriorityBlockingQueue 类。</p>
</li>
<li><p>注意3：不允许使用 null 元素。</p>
</li>
<li><p>注意4：插入方法<code>（offer()、poll()、remove() 、add() 方法）</code>时间复杂度为<code>O(log(n))</code> ；<br><code>remove(Object)</code> 和 <code>contains(Object)</code> 时间复杂度为<code>O(n)</code>；<br>检索方法（<code>peek、element 和 size</code>）时间复杂度为常量。</p>
</li>
<li><p>注意5：方法iterator()中提供的迭代器并不保证以有序的方式遍历优先级队列中的元素。（原因可参考PriorityQueue的内部实现）<br>如果需要按顺序遍历，可用Arrays.sort(pq.toArray())。</p>
</li>
<li><p>注意6：可以在构造函数中指定如何排序。如：<br><code>PriorityQueue()</code>使用默认的初始容量（11）创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用 Comparable）。<br><code>PriorityQueue(int initialCapacity)</code> 使用指定的初始容量创建一个 PriorityQueue，并根据其自然顺序来排序其元素（使用 Comparable）。<br><code>PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator)</code> 使用指定的初始容量创建一个 PriorityQueue，并根据指定的比较器comparator来排序其元素。</p>
</li>
<li><p>注意7：此类及其迭代器实现了 Collection 和 Iterator 接口的所有可选方法。</p>
</li>
</ul>
<p><strong>PriorityQueue对元素采用的是堆排序，头是按指定排序方式的最小元素。堆排序只能保证根是最大（最小），整个堆并不是有序的。方法iterator()中提供的迭代器可能只是对整个数组的依次遍历。也就只能保证数组的第一个元素是最小的。</strong></p>
<h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p><strong>标准写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>标准写法2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator&lt;Integer&gt;() &#123; </span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer e1, Integer e2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> e1 - e2;</span><br><span class="line">			&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>简化写法</strong><br><code>Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k, (v1,v2) -&gt; v1 - v2);</code></p>
<p>示例,求最大的k个数;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">        <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k, (v1,v2) -&gt; v1 - v2);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">            <span class="comment">// 当前数字大于堆顶元素才会入堆</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &gt; heap.peek()) &#123;</span><br><span class="line">                heap.offer(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll(); <span class="comment">// 删除堆顶最大元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">            res[j++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a = getLeastNumbers(arr,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><p><strong>标准写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p><strong>简化写法</strong></p>
<p><code>Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k, (v1,v2) -&gt; v2 - v1);</code></p>
<p>示例：求最小的k个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">topk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用一个最大堆（大顶堆）</span></span><br><span class="line">        <span class="comment">// Java 的 PriorityQueue 默认是小顶堆，添加 comparator 参数使其变成最大堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k, (v1,v2) -&gt; v1 - v2);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : arr) &#123;</span><br><span class="line">            <span class="comment">// 当前数字小于堆顶元素才会入堆</span></span><br><span class="line">            <span class="keyword">if</span> (heap.isEmpty() || heap.size() &lt; k || e &lt; heap.peek()) &#123;</span><br><span class="line">                heap.offer(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll(); <span class="comment">// 删除堆顶最大元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将堆中的元素存入数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[heap.size()];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : heap) &#123;</span><br><span class="line">            res[j++] = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] a = getLeastNumbers(arr,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : a)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">           PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           heap.offer(<span class="number">3</span>);</span><br><span class="line">           heap.offer(<span class="number">1</span>);</span><br><span class="line">           heap.offer(<span class="number">2</span>);</span><br><span class="line">           heap.offer(<span class="number">0</span>);</span><br><span class="line">           heap.offer(<span class="number">5</span>);</span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">           heap.peek();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i : heap)&#123;</span><br><span class="line">               System.out.print(i);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.print(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">           heap.poll();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i : heap)&#123;</span><br><span class="line">               System.out.print(i);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           System.out.print(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">           heap.poll();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i : heap)&#123;</span><br><span class="line">               System.out.print(i);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由以上代码可知，<strong>小根堆在堆顶元素出栈之后，堆还会自己调整结构，保证小根堆的堆顶是最小值。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>优先队列</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>java关键字volatile和synchronized(2)</title>
    <url>/2020/07/13/java%E5%85%B3%E9%94%AE%E5%AD%97volatile%E5%92%8Csynchronized-2/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/42497046">https://zhuanlan.zhihu.com/p/42497046</a><br><a href="https://zhuanlan.zhihu.com/p/111229417">https://zhuanlan.zhihu.com/p/111229417</a></p>
</blockquote>
<p>synchronized 是独占锁/排他锁（就是有你没我的意思），同时只能有一个线程调用 add10KCount 方法，其他调用线程会被阻塞。所以三行 CPU 指令都是同一个线程执行完之后别的线程才能继续执行，这就是通常说说的 原子性 （线程执行多条指令不被中断）</p>
<p>但 volatile 是非阻塞算法（也就是不排他），当遇到三行 CPU 指令自然就不能保证别的线程不插足了，这就是通常所说的，volatile 能保证内存可见性，但是不能保证原子性</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>java关键字volatile和synchronzied（1）</title>
    <url>/2020/07/09/java%E5%85%B3%E9%94%AE%E5%AD%97volatile%E5%92%8Csynchronzied/</url>
    <content><![CDATA[<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="/images/pasted-36.png" class="lazyload" data-srcset="/images/pasted-36.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>

<p>Java内存模型(java Memory Model)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。</p>
<h2 id="首先介绍几个概念"><a href="#首先介绍几个概念" class="headerlink" title="首先介绍几个概念"></a><strong>首先介绍几个概念</strong></h2><table>
<thead>
<tr>
<th>名词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>共享变量</td>
<td>如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。</td>
</tr>
<tr>
<td>原子性</td>
<td>一个操作/一系列操作要么全部执行，要么都不执行</td>
</tr>
<tr>
<td>可见性</td>
<td>一个线程对共享变量值的修改，能够及时地被其他线程看到</td>
</tr>
<tr>
<td>有序性</td>
<td>程序的运行顺序要和程序的逻辑顺序一致，可能实际情况是计算机考虑到性能的因素执行顺序有所不同，但是结果肯定会和逻辑顺序一致</td>
</tr>
</tbody></table>
<h3 id="共享变量可见性实现的原理"><a href="#共享变量可见性实现的原理" class="headerlink" title="共享变量可见性实现的原理"></a><strong>共享变量可见性实现的原理</strong></h3><p>  线程1对共享变量的修改要想被线程2及时看到，必须要经过如下两个步骤</p>
<ol>
<li>把工作内存1中更新过的共享变量刷新到主内存中</li>
<li>将主内存中最新的共享变量的值更新到工作内存2中</li>
</ol>
<p><img src="/images/pasted-37.png" class="lazyload" data-srcset="/images/pasted-37.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>其中，线程对共享变量的操作，遵循一下两条规则</p>
<ul>
<li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写</li>
<li>不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>要实现共享变量的可见性，必须保证两点：</p>
<p>线程修改后的共享变量值能够及时从工作内存刷新到主内存中<br>其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中</p>
<p>可见性的实现方式：</p>
<ul>
<li><p><strong><code>synchronized</code></strong></p>
</li>
<li><p><strong><code>volatile</code></strong></p>
</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile是java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两种特性：<br>1、保证此变量对所有线程的可见性，即当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。<br>2、禁止指令重排序</p>
<p>对于volatile的作用，《Java核心技术卷》是这么说的：</p>
<blockquote>
<p>为<code>实例域</code>的访问提供了一种免锁机制，不提供<code>原子性</code>。</p>
</blockquote>
<p>首先，<code>实例域</code>说明它是用来修饰域的，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isNum = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>其次，对实例域的访问提供了免锁机制说明volatile具有可见性；最后的重点就是没有原子性。<code>《Java编程思想》</code>中提到：</p>
<blockquote>
<p><code>所有的基础类型（除了double和long）的基础操作（读取和写入）都具有原子性，经过volatile修饰的long和double在基础操作中也会具有原子性。</code></p>
</blockquote>
<h3 id="volatile-实现可见性"><a href="#volatile-实现可见性" class="headerlink" title="volatile 实现可见性"></a>volatile 实现可见性</h3><p>volatile关键字</p>
<ul>
<li>能够保证volatile变量的可见性</li>
<li>不能保证volatile变量复合操作的原子性</li>
</ul>
<h4 id="volatile如何实现内存可见性："><a href="#volatile如何实现内存可见性：" class="headerlink" title="volatile如何实现内存可见性："></a>volatile如何实现内存可见性：</h4><p>深入来说：通过加入<code>内存屏障</code>和<code>禁止重排序优化</code>来实现的.</p>
<p>编译器在生成字节码时，会在volatile指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<ul>
<li>对volatile变量执行写操作时，会在写操作后加入一条store屏障指令</li>
<li>对volatile变量执行读操作时，会在读操作前加入一条load屏障指令</li>
</ul>
<p>通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存，这样任何时刻，不同的线程总能看到该变量的最新值。</p>
<h4 id="线程写volatile变量的过程："><a href="#线程写volatile变量的过程：" class="headerlink" title="线程写volatile变量的过程："></a>线程写volatile变量的过程：</h4><ol>
<li>改变线程工作内存中volatile变量副本的值</li>
<li>将改变后的副本的值从工作内存刷新到主内存</li>
</ol>
<h4 id="线程读volatile变量的过程："><a href="#线程读volatile变量的过程：" class="headerlink" title="线程读volatile变量的过程："></a>线程读volatile变量的过程：</h4><ol>
<li>从主内存中读取volatile变量的最新值到线程的工作内存中</li>
<li>从工作内存中读取volatile变量的副本</li>
</ol>
<h3 id="volatile适用场合"><a href="#volatile适用场合" class="headerlink" title="volatile适用场合"></a>volatile适用场合</h3><p>要在多线程中安全的使用volatile变量，必须同时满足：</p>
<ol>
<li><p>对变量的写入操作不依赖其当前值</p>
<ul>
<li>不满足：number++、count = count*5等</li>
<li>满足：boolean变量、记录温度变化的变量等</li>
</ul>
</li>
<li><p>该变量没有包含在具有其他变量的不变式中</p>
<ul>
<li>不满足：low&lt;up</li>
</ul>
</li>
</ol>
<p>下图是volatile不能实现原子性的示例：</p>
<p><img src="/images/pasted-38.png" class="lazyload" data-srcset="/images/pasted-38.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在Java中，所有实例对象都自动含有单一的锁（也称监视器）。所以，当使用synchronized修饰的方法的时候，该方法会自动给实例加锁，这个时候，其他含synchronized的方法必须等到该方法调用结束并释放锁之后，该方法才能够被调用。简单来说，就是同一时间内，只能有一个线程访问 synchronized修饰的方法或者代码块啊，保证了原子性、有序性和可视性。</p>
<h3 id="synchronized实现可见性："><a href="#synchronized实现可见性：" class="headerlink" title="synchronized实现可见性："></a>synchronized实现可见性：</h3><ul>
<li><p>原子性(同步)</p>
</li>
<li><p>可见性</p>
<h3 id="JMM关于synchronized的两条规定："><a href="#JMM关于synchronized的两条规定：" class="headerlink" title="JMM关于synchronized的两条规定："></a>JMM关于synchronized的两条规定：</h3></li>
<li><p>线程解锁前，必须把共享变量的最新值刷新到主内存中</p>
</li>
<li><p>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时，需要从主内存中重新读取最新的值(注意：加锁与解锁需要是同一把锁)</p>
</li>
</ul>
<p>注意：线程解锁前对共享变量的修改在下次加锁时对其他线程可见</p>
<h3 id="线程执行互斥代码的过程："><a href="#线程执行互斥代码的过程：" class="headerlink" title="线程执行互斥代码的过程："></a>线程执行互斥代码的过程：</h3><ul>
<li><p>获得互斥锁</p>
</li>
<li><p>清空工作内存</p>
</li>
<li><p>从主内存拷贝变量的最新副本到工作的内存</p>
</li>
<li><p>执行代码</p>
</li>
<li><p>将更改后的共享变量的值刷新到主内存</p>
</li>
<li><p>释放互斥锁</p>
</li>
</ul>
<h2 id="关键字的使用"><a href="#关键字的使用" class="headerlink" title="关键字的使用"></a>关键字的使用</h2><p>volatile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对一个域加上volatile，域可以确保可视性和有序性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对long和double加上volatile，可以使如下的读取和写入具有原子性。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getA</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span></span>&#123; <span class="keyword">this</span>.a = a;&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b；</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对象锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            a = a + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addThree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            b = b + <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addFour</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        b = b + <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上代码，我们看到synchronized的使用通常会分两种类型：</p>
<p>对象锁，synchronized修饰普通方法或者在代码块中使用的当前对象，分别对应着addOne()和addTwo()方法，该方法采用的是Test的对象锁，只针对单个Test实例的并发问题。</p>
<p>类锁，synchronized修饰静态方法或者在代码块中使用类对象，分别对应这addFour()和addThree()，这两个方法采用的是Test.Class的对象锁。当存在多个Test实例对象的时候，同一时间只有一个Test实例可以访问到addFour()方法或者addThree()中的代码块。</p>
<p>值得注意的是，一个任务可以多次获得对象的锁，当在一个synchronized方法中调用同一个对象的另一个synchronized方法，该方法就会使得JVM跟踪的线程的持有的锁的数量加一，方法调用结束的时候，持有锁的数量就会减一，直到数字减为零，锁才会被释放。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/images/pasted-39.png" class="lazyload" data-srcset="/images/pasted-39.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><strong>synchronized和volatile的区别</strong></p>
<ul>
<li>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；</li>
<li>从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；</li>
<li>synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</li>
</ul>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/61966479">https://zhuanlan.zhihu.com/p/61966479</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/1ae887521cf3">https://www.jianshu.com/p/1ae887521cf3</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/327daf7dff34">https://www.jianshu.com/p/327daf7dff34</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Synchronized</tag>
        <tag>Volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程</title>
    <url>/2020/07/22/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p>
<p>这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p>
<p>多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p>
<span id="more"></span>

<h3 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h3><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<p>下图显示了一个线程完整的生命周期。</p>
<p><img src="/images/pasted-53.png" class="lazyload" data-srcset="/images/pasted-53.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-54.png" class="lazyload" data-srcset="/images/pasted-54.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<ul>
<li><p>新建状态（NEW）:<br>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p>
</li>
<li><p>运行状态(RUNNABLE):<br>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统的称为”运行中”,</p>
<ul>
<li><p>就绪状态:<br>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:<br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
</ul>
</li>
<li><p>阻塞状态:<br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li><p>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</p>
</li>
<li><p>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</p>
</li>
<li><p>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</p>
</li>
</ul>
</li>
<li><p>WAITING:<br>等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）</p>
</li>
<li><p>超时等待(TIME_WAITING):<br>超时等待状态，该状态不同于WAITING, 它是可以指定的时间自行返回的</p>
</li>
<li><p>终止状态:<br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态，表示当前线程已经执行完毕</p>
</li>
</ul>
<p>一个线程在一个给定的时刻，线程只能处于其中一个状态.</p>
<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<h3 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h3><p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<p>通过线程池Excutor创建<br>（待更新）</p>
<h3 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h3><p>在多线程编程时，你需要了解以下几个概念：</p>
<ul>
<li>线程同步</li>
<li>线程间通信</li>
<li>线程死锁</li>
<li>线程控制：挂起、停止和恢复</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title> 并发与并行</title>
    <url>/2020/07/16/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发： <strong>操作系统中，指一个时间端内有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。</strong></p>
<p>并发不是真正意义上的“同时进行”，只是<strong>CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</strong>。如：打游戏和听音乐两件事情在同一个时间段内都是在同一台电脑上完成了从开始到结束的动作。那么，就可以说听音乐和打游戏是并发的。</p>
<span id="more"></span>

<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行（Parallel），<strong>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)</strong>。</p>
<p>决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>如下图所示：<br><img src="/images/pasted-47.png" class="lazyload" data-srcset="/images/pasted-47.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>所以，并发是在一段时间内宏观上多个程序同时运行，并行是在某一时刻，真正有多个程序在运行。</p>
<p>并行和并发的区别：</p>
<p>并发，指的是多个事情，在同一时间段内同时发生了。<br>并行，指的是多个事情，在同一时间点上同时发生了。</p>
<p>并发的多个任务之间是互相抢占资源的。<br>并行的多个任务之间是不互相抢占资源的、</p>
<p>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</p>
<blockquote>
<p><a href="https://www.cnblogs.com/xc-chejj/p/10813692.html">https://www.cnblogs.com/xc-chejj/p/10813692.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java接口</title>
    <url>/2020/07/21/java%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h2><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<span id="more"></span>

<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ol>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
<li>接口与类的区别：</li>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ol>
<h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3></li>
</ul>
<ol>
<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>
<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/2020/07/22/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p>
<p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。<br>泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<h2 id="泛型分类："><a href="#泛型分类：" class="headerlink" title="泛型分类："></a>泛型分类：</h2><p>泛型接口，泛型类，泛型方法</p>
<p>通过<strong>泛型可以定义类型安全的数据结构（类型安全），而无须使用实际的数据类型（可扩展）。这能够显著提高性能并得到更高质量的代码（高性能），因为您可以重用数据处理算法，而无须复制类型特定的代码（可重用）。</strong></p>
<span id="more"></span>
<h3 id="泛型接口："><a href="#泛型接口：" class="headerlink" title="泛型接口："></a>泛型接口：</h3><p>定义一个泛型接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Gener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现这个泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumGener</span> <span class="keyword">implements</span> <span class="title">Gener</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] ages = &#123;<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">text</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> ages[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumGener age =  <span class="keyword">new</span> NumGener();</span><br><span class="line">        System.out.println(age.text());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，把泛型参数改成String也是一样的。还可以把参数类型指定为一个自定义的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> weight;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">float</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumGener</span> <span class="keyword">implements</span> <span class="title">Gener</span>&lt;<span class="title">Man</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Man <span class="title">text</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Man man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">       man.setAge(<span class="number">18</span>);</span><br><span class="line">       man.setName(<span class="string">&quot;xiaoming&quot;</span>);</span><br><span class="line">       man.setSex(<span class="string">&#x27;M&#x27;</span>);</span><br><span class="line">       man.setWeight(<span class="number">6565</span>);</span><br><span class="line">       <span class="keyword">return</span> man;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumGener man =  <span class="keyword">new</span> NumGener();</span><br><span class="line">        System.out.println(man.text().name);</span><br><span class="line">        System.out.println(man.text().age);</span><br><span class="line">        System.out.println(man.text().sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><img src="/images/pasted-60.png" class="lazyload" data-srcset="/images/pasted-60.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">        Box&lt;String&gt; strBox = <span class="keyword">new</span> Box&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        integerBox.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        strBox.add(<span class="keyword">new</span> String(<span class="string">&quot;str&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;整型值为 : %d \n\n&quot;</span>, integerBox.get());</span><br><span class="line">        System.out.printf(<span class="string">&quot;字符串为 : %s \n&quot;</span>, strBox.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonSingle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">printer</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;<span class="comment">//普通的</span></span><br><span class="line">        System.out.print(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUperNumber</span><span class="params">(List&lt;? extends Number&gt; data)</span> </span>&#123;<span class="comment">//给通配符划分了范围</span></span><br><span class="line">         System.out.println(<span class="string">&quot;data :&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// List&lt;Number&gt; number = new ArrayList&lt;Number&gt;();</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">// name.add(&quot;icon&quot;);</span></span><br><span class="line">        <span class="comment">// age.add(18);</span></span><br><span class="line">        <span class="comment">// number.add(314);</span></span><br><span class="line">     </span><br><span class="line">        <span class="comment">// CommonSingle.printer(name);</span></span><br><span class="line">        <span class="comment">// CommonSingle.printer(age);</span></span><br><span class="line">        <span class="comment">// CommonSingle.printer(number);</span></span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">            </span><br><span class="line">        name.add(<span class="string">&quot;icon&quot;</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line">        <span class="comment">//CommonSingle.getUperNumber(name);//报错：因为S不在Number的范围内,Number 的参数列表为 Byte，Double, Float, Long, Short</span></span><br><span class="line">        </span><br><span class="line">        CommonSingle.getUperNumber(age);</span><br><span class="line">        CommonSingle.getUperNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型的通配符与上下界"><a href="#泛型的通配符与上下界" class="headerlink" title="泛型的通配符与上下界"></a>泛型的通配符与上下界</h2><p>常用的T，E, K, V, ?</p>
<ul>
<li>无界通配符 ？</li>
<li>上界通配符 &lt;? extends E&gt;</li>
<li>下界通配符 &lt;? super E&gt;</li>
<li>? 和 T</li>
</ul>
<p><strong>？表示不确定的 java 类型</strong> </p>
<pre><code>对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 ），表示可以持有任何类型</code></pre><p><strong>T (type) 表示具体的一个java类型</strong></p>
<p><strong>K V (key value) 分别代表java键值中的Key Value</strong></p>
<p><strong>E (element) 代表Element</strong></p>
<h4 id="T和？的区别"><a href="#T和？的区别" class="headerlink" title="T和？的区别"></a>T和？的区别</h4><p><img src="/images/pasted-61.png" class="lazyload" data-srcset="/images/pasted-61.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<p>// 可以<br>T t = operate();</p>
<p>// 不可以<br>？car = operate();<br>简单总结下：</p>
<p>T 是一个确定的类型，通常用于泛型类和泛型方法的定义，？是一个不确定的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt;? extends E&gt;"></a>上界通配符 &lt;? extends E&gt;</h4><pre><code>用 extends 关键字声明，表示参数化的类型可能是所指定的E类型，或者是此类型E的子类。</code></pre><ul>
<li>如果传入的参数不是E或者E的子类，编译不成功</li>
<li>泛型中可以使用E的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;K extends A, E extends B&gt; <span class="function">E <span class="title">test</span><span class="params">(K arg1, E arg2)</span></span>&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h4><pre><code>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</code></pre><p>参数类型中使用super表示这个泛型中的参数必须是E或者E的父类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jonathan</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantArrays</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定上界，上界为Fruit 父类，表示参数化类型可能时T或者时T的子类</span></span><br><span class="line">    List&lt;? extends Apple&gt; flistTop = <span class="keyword">new</span> ArrayList&lt;Jonathan&gt;();</span><br><span class="line">    flistTop.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//add Fruit对象会报错</span></span><br><span class="line">    <span class="comment">//父类不能add</span></span><br><span class="line">    <span class="comment">//flistTop.add(new Fruit());</span></span><br><span class="line">    Fruit fruit1 = flistTop.get(<span class="number">0</span>);</span><br><span class="line">    Apple app = flistTop.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(flistTop);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//下界，下届为Apple，表示参数化类型是此类型的超类型（父类型），直至Object</span></span><br><span class="line">    List&lt;? <span class="keyword">super</span> Apple&gt; flistBottem = <span class="keyword">new</span> ArrayList&lt;Fruit&gt;();</span><br><span class="line"></span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Apple());</span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">    <span class="comment">//add fruit 对象出错</span></span><br><span class="line">    <span class="comment">//flistBottem.add(new Fruit());</span></span><br><span class="line">    flistBottem.add(<span class="keyword">new</span> Jonathan());</span><br><span class="line">    System.out.println(flistBottem);</span><br><span class="line">    System.out.println(flistBottem.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println(flistBottem.get(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//get Apple对象会报错</span></span><br><span class="line">    <span class="comment">//Apple apple = flistBottem.get(0);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://www.cnblogs.com/1605-3QYL/p/12609999.html">https://www.cnblogs.com/1605-3QYL/p/12609999.html</a><br><a href="https://www.cnblogs.com/JokerShi/p/8117556.html">https://www.cnblogs.com/JokerShi/p/8117556.html</a><br><a href="https://www.cnblogs.com/minikobe/p/11547220.html">https://www.cnblogs.com/minikobe/p/11547220.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>java集合</title>
    <url>/2020/07/14/java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p><img src="/images/pasted-41.png" class="lazyload" data-srcset="/images/pasted-41.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<span id="more"></span>

<p><img src="/images/pasted-45.png" class="lazyload" data-srcset="/images/pasted-45.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><img src="/images/pasted-42.png" class="lazyload" data-srcset="/images/pasted-42.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p>
<p><strong>ArrayList是List使用中最常用的实现类，它的查询速度快，效率高，但增删慢，线程不安全。</strong></p>
<p>ArrayList 继承了 AbstractList ，并实现了 List 接口</p>
<p><img src="/images/pasted-44.png" class="lazyload" data-srcset="/images/pasted-44.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>ArrayList底层实现采用的数据结构是数组，并且数组默认大小为10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();  <span class="comment">//没有指定数组大小，使用默认值（默认大小是10）</span></span><br><span class="line"></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);  <span class="comment">// 指定数组大小为10，传如的参数便是数组的大小，传入为10时，跟默认值相同，所以是等同的</span></span><br></pre></td></tr></table></figure>


<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>jdk1.8的扩容算法：</p>
<p>newCapacity = oldCapacity + ( oldCapacity &gt;&gt; 1 );    </p>
<p>// oldCapacity &gt;&gt; 2  移位运算，此处相当于oldCapacity除以2，但是 &gt;&gt; 这种写法更加高效</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector的底层也是通过数组实现的，默认大小也是10。主要特点：查询快，增删慢 , 线程安全，但是效率低</p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>创建对象与ArrayList类似，但有一点不同，它可以设置扩容是容量增长大小。</p>
<h3 id="扩容机制-1"><a href="#扩容机制-1" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>jdk1.8的扩容算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">newCapacity = oldCapacity + ( ( capacityIncrement &gt; <span class="number">0</span> ) ? capacityIncrement : oldCapacity );</span><br></pre></td></tr></table></figure>

<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p>LinkedList底层是一个双向链表，它增删快，效率高，但是查询慢，线程不安全</p>
<p>LinkedList 继承了 AbstractSequentialList 类。</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用。</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用。</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p>
<h3 id="扩容机制-2"><a href="#扩容机制-2" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>由于它的底层实现是链表，所以没有容量大小的定义，只有上个节点，当前节点，下个节点，每个节点都有一个上级节点和一个下级节点。</p>
<p><img src="/images/pasted-43.png" class="lazyload" data-srcset="/images/pasted-43.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>Vector</tag>
        <tag>LinkedList</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>java面向对象</title>
    <url>/2020/06/29/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/hc1151310108/article/details/80499388">https://blog.csdn.net/hc1151310108/article/details/80499388</a></p>
</blockquote>
<h1 id="面向对象开发-设计-特征"><a href="#面向对象开发-设计-特征" class="headerlink" title="面向对象开发,设计,特征"></a>面向对象开发,设计,特征</h1><h2 id="面向对象开发"><a href="#面向对象开发" class="headerlink" title="面向对象开发"></a>面向对象开发</h2><p>   就是不断的创建对象，使用对象，指挥对象做事情。</p>
<h2 id="面向对象设计"><a href="#面向对象设计" class="headerlink" title="面向对象设计"></a>面向对象设计</h2><p>  其实就是在管理和维护对象之间的关系。</p>
<h2 id="面向对象特征"><a href="#面向对象特征" class="headerlink" title="面向对象特征"></a>面向对象特征</h2><pre><code>封装(encapsulation)
继承(inheritance)
多态(polymorphism)</code></pre><span id="more"></span>

<p>2个对象的内存图</p>
<p><img src="/images/pasted-24.png" class="lazyload" data-srcset="/images/pasted-24.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="匿名对象的两种使用情况"><a href="#匿名对象的两种使用情况" class="headerlink" title="匿名对象的两种使用情况"></a>匿名对象的两种使用情况</h3><p>•    对象调用方法仅仅一次的时候</p>
<p>•    作为实际参数传递</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	匿名对象：就是没有名字的对象。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	匿名对象的应用场景：</span></span><br><span class="line"><span class="comment">		A:调用方法，仅仅只调用一次的时候。</span></span><br><span class="line"><span class="comment">		注意：调用多次的时候，不适合。</span></span><br><span class="line"><span class="comment">		那么，这种匿名调用有什么好处吗?</span></span><br><span class="line"><span class="comment">		有，匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。</span></span><br><span class="line"><span class="comment">		B:匿名对象可以作为实际参数传递</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我爱学习&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		s.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoNameDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//带名字的调用</span></span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		s.show();</span><br><span class="line">		s.show();</span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//匿名对象</span></span><br><span class="line">		<span class="comment">//new Student();</span></span><br><span class="line">		<span class="comment">//匿名对象调用方法</span></span><br><span class="line">		<span class="keyword">new</span> Student().show();</span><br><span class="line">		<span class="keyword">new</span> Student().show(); <span class="comment">//这里其实是重新创建了一个新的对象</span></span><br><span class="line">		System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//匿名对象作为实际参数传递</span></span><br><span class="line">		StudentDemo sd = <span class="keyword">new</span> StudentDemo();</span><br><span class="line">		<span class="comment">//Student ss = new Student();</span></span><br><span class="line">		<span class="comment">//sd.method(ss); //这里的ss是一个实际参数</span></span><br><span class="line">		<span class="comment">//匿名对象</span></span><br><span class="line">		sd.method(<span class="keyword">new</span> Student());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在来一个</span></span><br><span class="line">		<span class="keyword">new</span> StudentDemo().method(<span class="keyword">new</span> Student());</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p><strong>封装原则</strong>：</p>
<ul>
<li><p>将不需要对外提供的内容都隐藏起来。</p>
</li>
<li><p>把属性隐藏，提供公共方法对其访问。</p>
</li>
</ul>
<p><strong>封装的优点</strong></p>
<ol>
<li><p>良好的封装能够减少耦合。</p>
</li>
<li><p>类内部的结构可以自由修改。</p>
</li>
<li><p>可以对成员变量进行更精确的控制。</p>
</li>
<li><p>隐藏信息，实现细节</p>
</li>
<li><p>提高代码复用性</p>
</li>
</ol>
<p><strong>封装关键字</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>private</th>
<th>Default</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包下</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>派生子类</td>
<td></td>
<td></td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>不同包下</td>
<td></td>
<td></td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<p><strong>this关键字</strong></p>
<p> this:代表所在类的对象引用</p>
<p>方法被哪个对象调用，this就代表那个对象</p>
<p><strong>什么时候使用this呢?</strong></p>
<p>局部变量隐藏成员变量</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>jdbc实现事务</title>
    <url>/2020/07/17/jdbc%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/storml/p/11393836.html">https://www.cnblogs.com/storml/p/11393836.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-1004 最大连续1的个数III</title>
    <url>/2020/09/05/leetcode-1004-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0III/</url>
    <content><![CDATA[<p>给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。</p>
<p>返回仅包含 1 的最长（连续）子数组的长度。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/max-consecutive-ones-iii</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p>解题思路：<br>滑动窗口的思想：滑动窗口的大小为包含k个0的子串，low指向滑动窗口的左边，high指向滑动窗口的右边（high不断向右移动）。一旦滑动窗口中，0的个数大于k个时，就将low右移，直至滑动窗口中的0的个数恢复至k个。用res变量来保存当前滑动窗口的大小，不断进行更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs.bs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlideWindows</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> countZero = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分情况，如果countZero 0的个数小于k</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 当 A[right] = 1 时，left 不变，right 继续移动</span></span><br><span class="line">        <span class="comment">// 2. 当 A[right] = 0 时，</span></span><br><span class="line">        <span class="comment">//    2.1 当0 的数量在 K 的范围内，left 不变，right 继续移动</span></span><br><span class="line">        <span class="comment">//    2.2 当0 的数量 &gt; K，</span></span><br><span class="line">        <span class="comment">//        2.2.1 当 A[left] == 0 时，即 left 指向了一个零，只需要 left 右移一格，就可以减少一个零</span></span><br><span class="line">        <span class="comment">//        2.2.2 当 A[left] == 1 时，即此时窗口内包了 K 个零，需要先移动至下个零，再右移一格才能减少一个零</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (; right &lt; arr.length; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (countZero &lt; k) &#123;</span><br><span class="line">                    countZero++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (countZero == k) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (arr[left] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//先移动到第一个0</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//去掉第一个0</span></span><br><span class="line">                    left++;</span><br><span class="line">                    <span class="comment">//此时left指针指向当前序列的第二个0，此时k-1个0</span></span><br><span class="line">                    <span class="comment">//遇到下一个arr[right] = 0 时，left++</span></span><br><span class="line">                    <span class="comment">//因为此时最左边的0已经组成不了最长子序列了</span></span><br><span class="line">                    <span class="comment">//而且每一次right++， max都会取最长子序列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for 循环中如果 arr[right] == 1, 则 right++</span></span><br><span class="line">            max = Math.max(max, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-215 数组中第K个最大元素</title>
    <url>/2020/08/31/leetcode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>第K大的数</p>
<ol>
<li><p>Arrays.sort()</p>
</li>
<li><p>快排，堆排</p>
</li>
<li><p>优先队列</p>
<span id="more"></span>

</li>
</ol>
<h3 id="基于快速排序的选择方法"><a href="#基于快速排序的选择方法" class="headerlink" title="基于快速排序的选择方法"></a>基于快速排序的选择方法</h3><p>主要思想：</p>
<ol>
<li>把数组划分为两部分</li>
<li>递归调用快排</li>
<li>每一次排序最终q左边n个数，右边m个数，q的索引为n</li>
<li>当n = arr.length - k时，这个数就是第k个最大元素</li>
</ol>
<p><img src="/images/pasted-68.png" class="lazyload" data-srcset="/images/pasted-68.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="keyword">int</span> target = len - k;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选取数组最左边的数为基准</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j也可以代表交换次数，小于pivot的数的个数，最终j的位置就是pivot的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> j = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 小于 pivot 的元素都被交换到前面</span></span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在之前遍历的过程中，满足 [left + 1, j] &lt; pivot，并且 (j, i] &gt;= pivot</span></span><br><span class="line">        swap(nums, j, left);</span><br><span class="line">        <span class="comment">// 交换以后 [left, j - 1] &lt; pivot, nums[j] = pivot, [j + 1, right] &gt;= pivot</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基于堆排序的选择方法"><a href="#基于堆排序的选择方法" class="headerlink" title="基于堆排序的选择方法"></a>基于堆排序的选择方法</h3><p>们也可以使用堆排序来解决这个问题——建立一个大根堆，做 k−1 次删除操作后堆顶元素就是我们要找的答案。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.构建大顶堆</span></span><br><span class="line">        <span class="comment">//最后一个非叶子节点的位置是 arr.length/2 - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="comment">//从最后一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">            adjustHeap(arr,i,arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">            swap(arr,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">            adjustHeap(arr,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];<span class="comment">//先取出当前元素i (初始为arr.length/2 - 1，代表最后一个非叶子节点)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">            <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[k] &gt; temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                i = k;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = temp;<span class="comment">//将temp值放到父节点位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> a ,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            heap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">            res = heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-486 预测赢家</title>
    <url>/2020/09/01/leetcode-486-%E9%A2%84%E6%B5%8B%E8%B5%A2%E5%AE%B6/</url>
    <content><![CDATA[<p>给定一个表示分数的数组，两个玩家先后拿分数，预测先手玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。</p>
<p>输入：[1, 5, 2]</p>
<p>输出：False</p>
<span id="more"></span>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>定义状态dp：</p>
<p><code>dp[i][j]dp[i][j]</code>表示先手玩家与后手玩家在<code>nums[i...j]</code>和<code>nums[i...j]</code>之间互相拿，先手玩家比后手玩家多的最大分数，注意：这是个差值(delta)，而且是个最大差值。</p>
<p>所以最后<code>dp[0][length-1]</code> 就是最终先手玩家比后手玩家多的最大分数，大于0则true。</p>
<blockquote>
<p>作者：a-fei-8<br>链接：<a href="https://leetcode-cn.com/problems/predict-the-winner/solution/ji-xiao-hua-ji-da-zhi-yu-ce-ying-jia-polar-bear-by/">https://leetcode-cn.com/problems/predict-the-winner/solution/ji-xiao-hua-ji-da-zhi-yu-ce-ying-jia-polar-bear-by/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p><img src="/images/pasted-77.png" class="lazyload" data-srcset="/images/pasted-77.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>先手玩家有两种拿法：</p>
<ol>
<li>先手拿开头的</li>
</ol>
<p>剩余区间[i+1][j],此时状态dp[i+1][j]表示后手玩家比先手玩家多的最大分数，所以<code>dp[i][j] = nums[i] - dp[i+1][j]</code></p>
<ol start="2">
<li><p>先手拿结尾的<br>剩余区间[i][j-1],此时状态dp[i][j-1]表示后手玩家比先手玩家多的最大分数，所以<code>dp[i][j] = nums[j] - dp[i][j-1]</code></p>
</li>
<li><p>最大化<br><code>dp[i][j] = max[nums[i]+(-dp[i+1][j]), nums[j]+(-dp[i][j-1])]</code></p>
</li>
</ol>
<p>作者：a-fei-8<br>链接：<a href="https://leetcode-cn.com/problems/predict-the-winner/solution/ji-xiao-hua-ji-da-zhi-yu-ce-ying-jia-polar-bear-by/">https://leetcode-cn.com/problems/predict-the-winner/solution/ji-xiao-hua-ji-da-zhi-yu-ce-ying-jia-polar-bear-by/</a><br>来源：力扣（LeetCode）<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// 动态规划 所用数组，dp[i][j]表示：在nums数组的i到j下标区间内，先手玩家比后手玩家 “最大”多的数值</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.max(nums[i] - dp[i+<span class="number">1</span>][j], nums[j] - dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>] &gt;= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-77 组合</title>
    <url>/2020/09/08/leetcode-77-%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p><code>给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<p>这里不需要考虑重复问题, 因为按照顺序选择，后面的数字一定大于前面的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span> || n &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> begin, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搜索起点上界 + 接下来要选的元素个数 - 1 = n, 这里的i不是索引，而是取值。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode-841钥匙和房间</title>
    <url>/2020/08/31/leetcode-841/</url>
    <content><![CDATA[<hr>
<p>输入: [[1],[2],[3],[]]</p>
<p>输出: true</p>
<span id="more"></span>
<p>解释:<br>我们从 0 号房间开始，拿到钥匙 1。</p>
<p>之后我们去 1 号房间，拿到钥匙 2。</p>
<p>然后我们去 2 号房间，拿到钥匙 3。</p>
<p>最后我们去了 3 号房间。</p>
<p>由于我们能够进入每个房间，我们返回 true。</p>
<hr>
<p>DFS:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] vis;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size();</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        dfs(rooms, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        vis[x] = <span class="keyword">true</span>;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> it : rooms.get(x))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[it])&#123;</span><br><span class="line">                dfs(rooms, it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS:<br>与DFS不同的是BFS是当前层级遍历完之后再遍历下一层级。DFS中for循环里面直接进入了下一层DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rooms.size(), num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        vis[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        que.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = que.poll();</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> it : rooms.get(x))&#123;</span><br><span class="line">                <span class="keyword">if</span>(!vis[it])&#123;</span><br><span class="line">                    vis[it] = <span class="keyword">true</span>;</span><br><span class="line">                    que.offer(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 95 不同的二叉搜索树</title>
    <url>/2020/07/21/leetcode-95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h3 id="构建单棵二叉搜索树"><a href="#构建单棵二叉搜索树" class="headerlink" title="构建单棵二叉搜索树"></a>构建单棵二叉搜索树</h3><p>选择一个根节点，递归的构建根节点的左，右子树</p>
<p>在二叉搜索树中，根据二叉搜索树的特性，根节点选择中间的值。</p>
<!---more--->

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//选择父节点</span></span><br><span class="line">   <span class="keyword">int</span> val = (start + end) / <span class="number">2</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构建父节点</span></span><br><span class="line">   TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//递归地构建左右子节点</span></span><br><span class="line">   root.left = helper(start, val - <span class="number">1</span>);</span><br><span class="line">   root.right = helper(val + <span class="number">1</span> , end);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建多棵二叉树"><a href="#构建多棵二叉树" class="headerlink" title="构建多棵二叉树"></a>构建多棵二叉树</h3><p>要构建多颗二叉树，问题就在于如何选择不同的根节点，以构建不同的树和子树。</p>
<p>在上面的代码中，在选择根结点的时候，可以这样改造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择所有可能的根结点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果按照上述递归函数的方法写，每次递归只能返回一颗树，我们需要的是多颗树，我们可以将不同的根结点装入List然后返回，实际上，上述代码可以改写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">        <span class="keyword">int</span> val = (start + end) / <span class="number">2</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line"></span><br><span class="line">        root.left = helper(start, val - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(val + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 装入所有根结点</span></span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，现在问题变成了如何构建root的左右子树，我们抛开复杂的递归函数，只关心递归的返回值，每次选择根结点root，我们</p>
<ul>
<li>递归构建左子树，并拿到左子树所有可能的根结点列表left</li>
<li>递归构建右子树，并拿到右子树所有可能的根结点列表right</li>
</ul>
<p>这个时候我们有了左右子树列表，我们的左右子树都是各不相同的，因为根结点不同，我们如何通过左右子树列表构建出所有的以root为根的树呢？</p>
<p>我们固定一个左孩子，遍历右子树列表，那么以当前为root根结点的树个数就为left.size() * right.size()个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            <span class="comment">// 如果当前子树为空，不加null行吗？</span></span><br><span class="line">            list.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">// 想想为什么这行不能放在这里，而放在下面？</span></span><br><span class="line">            <span class="comment">// TreeNode root = new TreeNode(i);</span></span><br><span class="line">            <span class="comment">// 因为要构建多个子树</span></span><br><span class="line">            List&lt;TreeNode&gt; leftnode = helper(start, i-<span class="number">1</span>);  </span><br><span class="line">            List&lt;TreeNode&gt; rightnode = helper(i+<span class="number">1</span>, end); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定左孩子，遍历右孩子</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode l : leftnode)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode r : rightnode)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    list.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于<code>TreeNode root = new TreeNode(i)</code>的放置的位置问题<br>如果这行代码放置在注释的地方，会造成一个问题，就是以当前为root根结点的树个数就<code>num = left.size() * right.size() &gt; 1</code>时，num棵子树会共用这个root结点，在下面两层for循环中，root的左右子树一直在更新，如果每次不新建一个root，就会导致num个root为根节点的树都相同。</p>
<p>关于如果当前子树为空，不加null行不行的问题<br>显然，如果一颗树的左子树为空，右子树不为空，要正确构建所有树，依赖于对左右子树列表的遍历，也就是上述代码两层for循环的地方，如果其中一个列表为空，那么循环都将无法进行。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/cong-gou-jian-dan-ke-shu-dao-gou-jian-suo-you-shu-/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/cong-gou-jian-dan-ke-shu-dao-gou-jian-suo-you-shu-/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 从前序遍历和中序遍历构造二叉树</title>
    <url>/2020/07/31/leetcode-%E4%BB%8E%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode378 有序矩阵第K小元素</title>
    <url>/2020/07/22/leetcode378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E7%AC%ACK%E5%B0%8F%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p>给定一个<code>n x n</code> 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</p>
<span id="more"></span>
<h3 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] sorted = <span class="keyword">new</span> <span class="keyword">int</span>[rows * columns];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : matrix) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : row) &#123;</span><br><span class="line">                sorted[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(sorted);</span><br><span class="line">        <span class="keyword">return</span> sorted[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-55.png" class="lazyload" data-srcset="/images/pasted-55.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>由题目给出的性质可知，这个矩阵的每一行均为一个有序数组。问题即转化为从这 n*n 个有序数组中找第 k大的数，可以想到利用归并排序的做法，归并到第 k 个数即可停止。</p>
<p>一般归并排序是两个数组归并，而本题是 n 个数组归并，所以需要用小根堆维护，以优化时间复杂度</p>
<p>参考 leetcode 23 合并K个排序链表</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//优先队列，默认小根堆</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//堆中存了数组每一行的第一个值，行数，和0</span></span><br><span class="line">        <span class="comment">//排序序列为每一行的第一个值的小根堆序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// new出来的int数组 第一位存的是值，第二位存的是行号，最后一列存的是列号</span></span><br><span class="line">            pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[i][<span class="number">0</span>], i, <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面最小堆出队k-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] now = pq.poll();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果数组没有遍历到最后一列</span></span><br><span class="line">            <span class="comment">//往堆中添加当前堆中最小值的右边一位的值，行号，列号</span></span><br><span class="line">            <span class="comment">//由于最小值出堆后，堆的结构会自动调整，堆顶的元素始终为最小值。</span></span><br><span class="line">            <span class="comment">//下一次，出堆的一定是加入上一次最小值右边后，堆调整后的最小值</span></span><br><span class="line">            <span class="comment">//出堆一次，选择一个大于刚才堆顶元素的值入堆</span></span><br><span class="line">            <span class="comment">//搜索顺序是不确定的，</span></span><br><span class="line">            <span class="comment">//但是是根据当前最小值进行搜索的</span></span><br><span class="line">            <span class="keyword">if</span> (now[<span class="number">2</span>] != n - <span class="number">1</span>) &#123;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[now[<span class="number">1</span>]][now[<span class="number">2</span>] + <span class="number">1</span>], now[<span class="number">1</span>], now[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//栈顶元素就是第k小的元素</span></span><br><span class="line">        <span class="keyword">return</span> pq.poll()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个数组的优先队列写法和标准写法不太相同。</p>
<p>泛型参数为int[],比较的是数组的第一个元素，构造的是小根堆。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql 索引</title>
    <url>/2020/07/01/mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h1><ul>
<li><p>单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。</p>
</li>
<li><p>组合索引，即一个索引包含多个列。</p>
</li>
</ul>
<p>索引是在<strong>存储引擎</strong>中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。</p>
<span id="more"></span>
<p><strong>优点</strong>：</p>
<p>　1、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引<br>　2、大大加快数据的查询速度</p>
<p><strong>缺点</strong>：</p>
<p>1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加</p>
<p>2、索引也需要占空间，我们知道数据表中的数据也会有最大上限设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上限值</p>
<p>3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。</p>
<p><strong>使用原则</strong>：</p>
<p>  通过上面说的优点和缺点，我们应该可以知道，并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用。</p>
<p>　1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，</p>
<p>　2、数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</p>
<p>　3、在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可以建立索引。</p>
<p> 一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL的B-Tree只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及不以通配符开始的LIKE才会使用索引。</p>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><p>这是最基本的索引，它没有任何限制。普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件(WHERE column = …)或排序条件(ORDER BY column)中的数据列创建索引。</p>
<p>它有以下几种创建方式：</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p><strong>(1)使用 CREATE INDEX 语句</strong></p>
<p><code>CREATE &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC])</code></p>
<p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。</p>
<p><strong>(2)修改表结构</strong></p>
<p><code>ALTER &lt;表名&gt; ADD INDEX [indexName] ON [表名(列名)]</code></p>
<p><strong>(3)创建表的时候直接指定</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_index</span><br><span class="line">(   id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment  ,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index index_name <span class="keyword">On</span>  table_index( name );</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_index</span><br><span class="line">(   id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment  ,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_index</span><br><span class="line"><span class="keyword">add</span> index index_name (name);</span><br></pre></td></tr></table></figure>
<p>实际操作：</p>
<p><strong><code>create index on actor(first_name);</code></strong></p>
<h3 id="删除索引的语法："><a href="#删除索引的语法：" class="headerlink" title="删除索引的语法："></a>删除索引的语法：</h3><p><code>DROP INDEX first ON actor;</code></p>
<p>删除完展示所有的索引<br><code>show index from actor</code></p>
<p><img src="/images/pasted-31.png" class="lazyload" data-srcset="/images/pasted-31.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>它与前面的普通索引类似，不同的就是：普通索引允许被索引的数据列包含重复的值。而<strong>唯一索引列的值必须唯一</strong>，但<strong>允许有空值</strong>。如果是组合索引，则列值的组合必须唯一。</p>
<p><code>CREATE UNIQUE INDEX indexName ON  table(columename)</code></p>
<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p><strong>它是一种特殊的唯一索引，不允许有空值</strong>。一个表只能有一个主键。<br>一般是在建表的时候同时创建主键索引：</p>
<p>见上面<strong>(3)创建表的时候直接指定</strong>部分</p>
<p>与之类似的，外键索引</p>
<p>如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>为了形象地对比单列索引和组合索引，为表添加多个字段：</p>
<p><code>CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL );</code></p>
<p>为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里：</p>
<p><code>ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);</code></p>
<p>建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。</p>
<p><img src="/images/pasted-32.png" class="lazyload" data-srcset="/images/pasted-32.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>建立这样的组合索引，其实是相当于分别建立了下面三组组合索引：</p>
<p><code>usernname,city,age</code></p>
<p><code>usernname,city</code></p>
<p><code>usernname</code></p>
<p>为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引。下面的几个SQL就会用到这个组合索引：</p>
<p><code>SELECT * FROM mytable WHREE username=&quot;admin&quot; AND city=&quot;郑州&quot;</code></p>
<p><code>SELECT * FROM mytable WHREE username=&quot;admin&quot;</code></p>
<p>而下面几个则不会用到：</p>
<p><code>SELECT * FROM mytable WHREE age=20 AND city=&quot;郑州&quot;</code></p>
<p><code>SELECT * FROM mytable WHREE city=&quot;郑州&quot;</code></p>
<p>如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。因为虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。</p>
<p>组合索引的使用要遵守“最左前缀”原则’</p>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。</p>
<p>全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有”你是个靓仔，靓女 …” 通过靓仔，可能就可以找到该条记录。</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/0d6c828d3c70">https://www.jianshu.com/p/0d6c828d3c70</a><br><a href="https://zhuanlan.zhihu.com/p/29118331">https://zhuanlan.zhihu.com/p/29118331</a><br><a href="https://www.jianshu.com/p/0d6c828d3c70">https://www.jianshu.com/p/0d6c828d3c70</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>索引</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>new 和 newInstance()方法的区别</title>
    <url>/2020/09/13/new-%E5%92%8C-newInstance-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/luckykapok918/article/details/50186797">https://blog.csdn.net/luckykapok918/article/details/50186797</a></p>
]]></content>
  </entry>
  <entry>
    <title>python2.7 向Elasticsearch中插入数据</title>
    <url>/2020/06/02/python2-7-%E5%90%91Elasticsearch%E4%B8%AD%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h3 id="1-首先需要创建索引和type"><a href="#1-首先需要创建索引和type" class="headerlink" title="1.首先需要创建索引和type"></a>1.首先需要创建索引和type</h3><p>Elasticsearch 6.x版本以上type逐渐放弃使用</p>
<p>创建索引可以使用transport client 也可以使用highlevelrestclient 来操作。<br>单机版本指定分片1，副本0.</p>
<span id="more"></span>
<blockquote>
<p>参考<a href="https://github.com/huanshi2/EHRelasticsearch">https://github.com/huanshi2/EHRelasticsearch</a></p>
</blockquote>
<h3 id="2-使用9200端口post数据"><a href="#2-使用9200端口post数据" class="headerlink" title="2.使用9200端口post数据"></a>2.使用9200端口post数据</h3><p><code>Person.json</code>结构：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">&quot;subj&quot;</span>: <span class="string">&quot;A.R.拉曼&quot;</span>, <span class="attr">&quot;po&quot;</span>: [&#123;<span class="attr">&quot;pred&quot;</span>: <span class="string">&quot;birthDate&quot;</span>, <span class="attr">&quot;obj&quot;</span>: <span class="string">&quot;1966年1月6日&quot;</span>&#125;]&#125;</span><br><span class="line">&#123;<span class="attr">&quot;subj&quot;</span>: <span class="string">&quot;A.帕拉第奥&quot;</span>, <span class="attr">&quot;po&quot;</span>: [&#123;<span class="attr">&quot;pred&quot;</span>: <span class="string">&quot;birthPlace&quot;</span>, <span class="attr">&quot;obj&quot;</span>: <span class="string">&quot;帕多瓦&quot;</span>&#125;, &#123;<span class="attr">&quot;pred&quot;</span>: <span class="string">&quot;nationality&quot;</span>, <span class="attr">&quot;obj&quot;</span>: <span class="string">&quot;意大利&quot;</span>&#125;, &#123;<span class="attr">&quot;pred&quot;</span>: <span class="string">&quot;代表作品&quot;</span>, <span class="attr">&quot;obj&quot;</span>: <span class="string">&quot;建筑四论&quot;</span>&#125;]&#125;</span><br><span class="line">&#123;<span class="attr">&quot;subj&quot;</span>: <span class="string">&quot;ALEX（寂静岭5中主角）&quot;</span>, <span class="attr">&quot;po&quot;</span>: [&#123;<span class="attr">&quot;pred&quot;</span>: <span class="string">&quot;birthDate&quot;</span>, <span class="attr">&quot;obj&quot;</span>: <span class="string">&quot;1985年&quot;</span>&#125;, &#123;<span class="attr">&quot;pred&quot;</span>: <span class="string">&quot;gender&quot;</span>, <span class="attr">&quot;obj&quot;</span>: <span class="string">&quot;男&quot;</span>&#125;, &#123;<span class="attr">&quot;pred&quot;</span>: <span class="string">&quot;年龄&quot;</span>, <span class="attr">&quot;obj&quot;</span>: <span class="string">&quot;22（2007年）&quot;</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>
<p><code>insert.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> simplejson <span class="keyword">as</span> json</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_insert</span>(<span class="params">base_url, data</span>):</span></span><br><span class="line">    response = requests.post(base_url, headers=&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;application/x-ndjson&quot;</span>&#125;, data=data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">begin_insert_job</span>(<span class="params">index_name,json_filepath, bulk_size=<span class="number">1000</span></span>):</span></span><br><span class="line">    base_url = <span class="string">&quot;http://localhost:9200/&quot;</span> + index_name + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;_doc&quot;</span> + <span class="string">&quot;/_bulk&quot;</span></span><br><span class="line">    f = <span class="built_in">open</span>(json_filepath)</span><br><span class="line">    cnt, es_id = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    data = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> tqdm(f):</span><br><span class="line">        action_meta = <span class="string">&#x27;&#123;&quot;index&quot;: &#123;&quot;_id&quot;:&quot;&#x27;</span> + <span class="built_in">str</span>(es_id) + <span class="string">&#x27;&quot;&#125;&#125;&#x27;</span></span><br><span class="line">        data = data + action_meta + <span class="string">&quot;\n&quot;</span> + line</span><br><span class="line"></span><br><span class="line">        es_id += <span class="number">1</span></span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt &gt;= bulk_size:</span><br><span class="line">            bulk_insert(base_url, data)</span><br><span class="line">            cnt, data = <span class="number">0</span>, <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (es_id % bulk_size):</span><br><span class="line">            <span class="built_in">print</span> es_id</span><br><span class="line">    <span class="keyword">if</span> cnt:</span><br><span class="line">        bulk_insert(base_url, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    begin_insert_job(<span class="string">&quot;demo&quot;</span>,<span class="string">&quot;./data/Person.json&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>必须使用python2</p>
<p>bulk: Elasticsearch 批量操作</p>
<p>requests函数需要添加请求头</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>sleep,wait和yield的区别</title>
    <url>/2020/08/30/sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="sleep-和-wait的区别"><a href="#sleep-和-wait的区别" class="headerlink" title="sleep 和 wait的区别"></a>sleep 和 wait的区别</h2><ol>
<li>wait只能再同步状态下调用，sleep是静态方法，当前线程Thread.sleep()就可以调用</li>
<li>wait状态线程能被nofify和notifyAll方法唤醒，但是sleeping状态不能</li>
<li>wait通常有条件地执行，线程一直处于wait状态直到某个条件变为真。但是sleep仅仅让线程进入睡眠状态</li>
<li>wait方法进入wait状态会释放锁，sleep不会</li>
<li>wait方法是针对一个被同步代码块加锁的对象，而sleep是针对一个线程<span id="more"></span>

</li>
</ol>
<h2 id="yeild-和-sleep的区别"><a href="#yeild-和-sleep的区别" class="headerlink" title="yeild 和 sleep的区别"></a>yeild 和 sleep的区别</h2><p>yield和sleep的主要是，yield方法会临时暂停当前正在执行的线程，来让有同样优先级的正在等待的线程有机会执行。如果没有正在等待的线程，或者所有正在等待的线程的优先级都比较低，那么该线程会继续运行。执行了yield方法的线程什么时候会继续运行由线程调度器来决定，不同的厂商可能有不同的行为。yield方法不保证当前的线程会暂停或者停止，但是可以保证当前线程在调用yield方法时会放弃CPU。</p>
<h2 id="sleep-方法的几个注意点"><a href="#sleep-方法的几个注意点" class="headerlink" title="sleep 方法的几个注意点"></a>sleep 方法的几个注意点</h2><ol>
<li>Thread.sleep()方法用来暂停线程的执行，将CPU放给线程调度器。</li>
<li>Thread.sleep()方法是一个静态方法，它暂停的是当前执行的线程。</li>
<li>Java有两种sleep方法，一个只有一个毫秒参数，另一个有毫秒和纳秒两个参数。</li>
<li>与wait方法不同，sleep方法不会释放锁</li>
<li>如果其他的线程中断了一个休眠的线程，sleep方法会抛出Interrupted Exception。</li>
<li>休眠的线程在唤醒之后不保证能获取到CPU，它会先进入就绪态，与其他线程竞争CPU。</li>
<li>有一个易错的地方，当调用t.sleep()的时候，会暂停线程t。这是不对的，因为Thread.sleep是一个静态方法，它会使当前线程而不是线程t进入休眠状态。</li>
</ol>
<blockquote>
<p><a href="https://www.jianshu.com/p/25e959037eed">https://www.jianshu.com/p/25e959037eed</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp与udp区别</title>
    <url>/2020/08/30/tcp%E4%B8%8Eudp%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>TCP为什么是三次握手</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title>volantis主题升级</title>
    <url>/2020/10/14/volantis%E4%B8%BB%E9%A2%98%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1.下载源码"></a>1.下载源码</h2><p>备份之后直接替换</p>
<span id="more"></span>

<p><img src="/images/pasted-138.png" class="lazyload" data-srcset="/images/pasted-138.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="2-修改主题config-yml"><a href="#2-修改主题config-yml" class="headerlink" title="2.修改主题config.yml"></a>2.修改主题config.yml</h2><p>之前的头像需要显示修改layout里面meta中的author.ejs<br>现在新版主题不知道是否还需要修改，查看源码应该不需要了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">let author = theme.article.body.meta_library.author;</span><br><span class="line">let aid = post.author;</span><br><span class="line">if (aid &amp;&amp; site.data &amp;&amp; site.data.author &amp;&amp; (aid in site.data.author)) &#123;</span><br><span class="line">  author = site.data.author[aid];</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;div class=&#x27;new-meta-item author&#x27;&gt;</span><br><span class="line">  &lt;a class=&#x27;author&#x27; href=&quot;&lt;%- author.url %&gt;&quot; rel=&quot;nofollow&quot;&gt;</span><br><span class="line">    &lt;img no-lazy src=&quot;&lt;%- author.avatar %&gt;&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;%- author.name %&gt;&lt;/p&gt;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/pasted-139.png" class="lazyload" data-srcset="/images/pasted-139.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="3-重新deploy"><a href="#3-重新deploy" class="headerlink" title="3.重新deploy"></a>3.重新deploy</h2><h2 id="4-主题得到了美化"><a href="#4-主题得到了美化" class="headerlink" title="4.主题得到了美化"></a>4.主题得到了美化</h2>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>WordNet和中文Wordnet</title>
    <url>/2020/05/28/wordnet/</url>
    <content><![CDATA[<h2 id="1-WordNet"><a href="#1-WordNet" class="headerlink" title="1. WordNet"></a>1. WordNet</h2><p>WordNet是由Princeton 大学的心理学家，语言学家和计算机工程师联合设计的一种基于认知语言学的英语词典。它不是光把单词以字母顺序排列，而且按照单词的意义组成一个“单词的网络”。</p>
<p> 它是一个覆盖范围宽广的英语词汇语义网。名词，动词，形容词和副词各自被组织成一个同义词的网络，每个同义词集合都代表一个基本的语义概念，并且这些集合之间也由各种关系连接。</p>
<span id="more"></span>
<p> WordNet包含描述概念含义，一义多词，一词多义，类别归属，近义，反义等问题，访问以下网页，可使用wordnet的基本功能</p>
<p><a href="http://wordnetweb.princeton.edu/perl/webwn">http://wordnetweb.princeton.edu/perl/webwn</a></p>
<p>部分功能:</p>
<p>(1) 上位词/下位词</p>
<p>(2) 同义词/反义词</p>
<p>(3) 蕴涵关系</p>
<p>(4) 整体与部位</p>
<p>(5) 计算概念之间距离</p>
<h2 id="2-中文词汇网路"><a href="#2-中文词汇网路" class="headerlink" title="2. 中文词汇网路:"></a>2. 中文词汇网路:</h2><p><a href="http://openkg.cn/dataset/chinese-wordnet">http://openkg.cn/dataset/chinese-wordnet</a></p>
<p><img src="https://wx2.sbimg.cn/2020/05/28/image-20200528151407552.png" class="lazyload" data-srcset="https://wx2.sbimg.cn/2020/05/28/image-20200528151407552.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200528151407552"></p>
<p>OpenKG收集和整理国内国外重要的开放知识库和知识图谱项目，并组织整理相关的中文资料免费对外开放。</p>
<p>中文词汇网路 (Chinese Wordnet, 以下简称中文词网) 计画，目的是在提供完整的中文词义 (sense) 区分与词汇语意关系知识库。相信词义的区分与表达，必须建立在完善的词汇语意学 (lexical semantics) 理论与知识本体 (ontology) 架构基础上。在词义理论与认知研究方面，这个详细分析的词汇知识库系统，将成為语言学研究的基本参考资料。在实际的应用上，这个资料库可望成為中文语言处理与知识工程不可或缺的基底架构。</p>
<p>本计划自 2003 年起，迄今累积了近十年的研究成果，对词义区分定义，与词义知识表达方式，渐次做了修正。建构过程中，也曾发表於国内外相关研究机关与数个国际研讨会议，得到了许多有价值的建议。中文词网的网路搜寻介面，在 2006 年於中央研究院语言学研究所正式啟用，提供给各界检索使用。到 2010 计画执行结束前，网站资料与技术报告内容皆作同步更新。为了永续经营此项珍贵的中文词汇资源，目前计画网站转由国立台湾大学语言学研究所维护。</p>
<p>CSC中文语义词库:</p>
<p>CSC 是一个自主研制的软件系统, 核心是一个中文语义词库。该版本可查阅 18 万以上中文词语、22 万以上义项的同义、分类、反义等方面的语义信息, 其中含有超过 50 种关系类型、超过 200 万个关系实例, 大约 13 万的词语或义项带有同义词。整个词库呈现为比较复杂的网络结构, 并带有多种检索手段和显示方式。该词库也是一种较简化的知识本体或知识库, 有类似著名英文词库 WordNet 的用途, 可作为智能搜索、自然语言处理等领域的辅助资源。</p>
<p><img src="https://wx1.sbimg.cn/2020/05/28/image-20200528152336026.png" class="lazyload" data-srcset="https://wx1.sbimg.cn/2020/05/28/image-20200528152336026.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200528152336026.png"></p>
<p>cwb中文分类词库 中文语义词库:</p>
<p>这是一个略具规模的中文语义词库, 也是稍有特色的汉语语义词典。它含有 10 万以上的词条, 每个词条通过关系比较密切的相关词 (例如同义词、反义词、上位词、下位词等) 与其它词条相连结。整个词库呈现为比较复杂的网络结构, 并带有多种检索手段和显示方式。</p>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>实体关系</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 HashMap 常用 String 对象作 key</title>
    <url>/2020/08/27/%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E5%B8%B8%E7%94%A8-String-%E5%AF%B9%E8%B1%A1%E4%BD%9C-key/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/codejas/article/details/78837830">https://blog.csdn.net/codejas/article/details/78837830</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要重写HashCode方法和equals方法？</title>
    <url>/2020/09/11/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99HashCode%E6%96%B9%E6%B3%95%E5%92%8Cequals%E6%96%B9%E6%B3%95%EF%BC%9F/</url>
    <content><![CDATA[<p><code>hashCode()</code>用本地方法返回内存地址。</p>
<p><code>equals</code>比较的是两个对象是否相等。</p>
<span id="more"></span>

<h3 id="1-Object-hashCode的通用约定"><a href="#1-Object-hashCode的通用约定" class="headerlink" title="1.Object.hashCode的通用约定"></a>1.<code>Object.hashCode</code>的通用约定</h3><blockquote>
<ul>
<li>在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么，对该对象调用hashCode方法多次，它必须始终如一地返回 同一个整数。在同一个应用程序的多次执行过程中，这个整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。</li>
<li>如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。</li>
<li>如果两个对象根据equals(Object)方法是不相等的，那么调用这两个对象中任一个对象的hashCode方法，不要求必须产生不同的整数结果。然而，程序员应该意识到这样的事实，对于不相等的对象产生截然不同的整数结果，有可能提高散列表（hash table）的性能。</li>
</ul>
</blockquote>
<h3 id="2-重写hashCode方法"><a href="#2-重写hashCode方法" class="headerlink" title="2.重写hashCode方法"></a>2.重写hashCode方法</h3><p>自定义对象插入<code>HashMap</code>时，首先需要根据内存地址确定<code>Key</code>在<code>hashMap</code>数组中的索引。但是原来的<code>hashCode</code>函数计算的时内存中的地址，造成new的两个相同的对象的<code>hashCode</code>不相等。但是<code>HashMap</code>中相同对象的索引应该相同，所以此时需要重写<code>hashCode</code>方法。</p>
<h3 id="3-重写equals方法"><a href="#3-重写equals方法" class="headerlink" title="3.重写equals方法"></a>3.重写equals方法</h3><p>重写了hashCode方法之后，两个相同对象在HashMap中的索引已经相等了，还需要判断equals，因为hashCode相同，两个对象还可能不相等，所以还需要判断equals。判断该对象类型和参数是否相等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之,重写<code>hashCode</code>和<code>equals</code>的目的是保证相同的自定义对象在<code>HashMap</code>中的Entry数组上是唯一的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs.lx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashAndEquals</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMapKey k1 = <span class="keyword">new</span> HashMapKey(<span class="number">1</span>);</span><br><span class="line">        System.out.println(k1.hashCode());</span><br><span class="line"></span><br><span class="line">        HashMapKey k2 = <span class="keyword">new</span> HashMapKey(<span class="number">1</span>);</span><br><span class="line">        System.out.println(k2.hashCode());</span><br><span class="line"></span><br><span class="line">        System.out.println(k1 == k2);</span><br><span class="line">        System.out.println(k1.equals(k2));</span><br><span class="line"></span><br><span class="line">        HashMap&lt;HashMapKey, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(k1, <span class="string">&quot;我是一个程序员&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;map.get(k2) : &quot;</span> + map.get(k2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashMapKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMapKey</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || !(o <span class="keyword">instanceof</span> HashMapKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getId().equals(((HashMapKey) o).getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/61307537">https://zhuanlan.zhihu.com/p/61307537</a><br><a href="https://blog.csdn.net/zknxx/article/details/53862572">https://blog.csdn.net/zknxx/article/details/53862572</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>乐观锁和悲观锁</title>
    <url>/2020/08/30/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/kismetv/p/10787228.html">https://www.cnblogs.com/kismetv/p/10787228.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>二叉搜索树中比k小的数</title>
    <url>/2020/08/30/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%AF%94k%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/06/07/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>演示网站<br><a href="http://520it.com/binarytrees/">http://520it.com/binarytrees/</a></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树是一种一对多的数据结构。树又有很多子集，比如：二叉树、二叉搜索树、2-3树、红黑树等等。树的特征：<br>1.没有父结点的结点叫根，一个数有且只有一个根;<br>2.每个结点有0个或多个子结点;<br>3.一颗树里也可拥有子树，且子树不能相交;</p>
<span id="more"></span>

<h2 id="度"><a href="#度" class="headerlink" title="度"></a>度</h2><p>每个结点拥有的子树数量称为该结点的度，简单的说结点的子节点个数就是它的度。<br>二叉树<br>二叉树是一类特殊的树，二叉树的特征：<br>1.每个结点最多有2个子结点的树（就是不存在度大于2的结点）；<br>2.左右子树有一定顺序（比如升序或降序，如下图中8的右子结点大于左子节点，结点2和7的子节点也是如此关系）；</p>
<p><img src="/images/pasted-1.png" class="lazyload" data-srcset="/images/pasted-1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>满二叉树是所有非叶结点的子结点个数都为2，看起来呈水平对称。其特征为：<br>1.所有叶结点都在最后一层；<br>2.非叶结点的所有结点的度都为2；</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>完全二叉树的特征：<br>1.该树非最后一层的结点都是满的；<br>2.最后一层的叶结点必须集中到左边，也就是不允许倒数第二层的结点只有右子结点而没左结点。</p>
<p><img src="/images/pasted-2.png" class="lazyload" data-srcset="/images/pasted-2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>完全二叉树是一种高效的数据结构，堆就是从程序实现层面上使完全二叉树更加容易操作（如：增、删）的数据结构。</p>
<h2 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h2><p>排序二叉树要么是一棵空二叉树，要么是具有下列性质的二叉树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>它的左、右子树也分别为排序二叉树。</li>
</ul>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树在原有的排序二叉树增加了如下几个要求： </p>
<ul>
<li>性质 1：每个节点要么是红色，要么是黑色。</li>
<li>性质 2：根节点永远是黑色的。</li>
<li>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</li>
<li>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</li>
<li>性质 5：<strong>从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点</strong></li>
</ul>
<h2 id="红黑树和平衡二叉树"><a href="#红黑树和平衡二叉树" class="headerlink" title="红黑树和平衡二叉树"></a>红黑树和平衡二叉树</h2><p>红黑树并不是真正的平衡二叉树，但在实际应用中，红黑树的统计性能要高于平衡二叉树，但极端性能略差。</p>
<p>由此我们可以得出结论：对于给定的黑色高度为 N 的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。</p>
<p>提示：排序二叉树的深度直接影响了检索的性能，正如前面指出，当插入节点本身就是由小到大排列时，排序二叉树将变成一个链表，这种排序二叉树的检索性能最低：N 个节点的二叉树深度就是 N-1。</p>
<p>红黑树通过上面这种限制来保证它大致是平衡的——因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。</p>
<p>由于红黑树只是一个特殊的排序二叉树，因此对红黑树上的只读操作与普通排序二叉树上的只读操作完全相同，只是红黑树保持了大致平衡，因此检索性能比排序二叉树要好很多。</p>
<p>但在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/140f99add232">https://www.jianshu.com/p/140f99add232</a><br><a href="https://www.cnblogs.com/guweiwei/p/7080971.html">https://www.cnblogs.com/guweiwei/p/7080971.html</a><br><a href="https://www.jianshu.com/p/bf73c8d50dc2">https://www.jianshu.com/p/bf73c8d50dc2</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的下一个节点</title>
    <url>/2020/06/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">链接：https:<span class="comment">//www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e?f=discussion</span></span><br><span class="line">来源：牛客网</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;    <span class="comment">//如果有右子树，则找右子树的最左节点</span></span><br><span class="line">            node = node.right;</span><br><span class="line">            <span class="keyword">while</span>(node.left!=<span class="keyword">null</span>) node = node.left;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123; <span class="comment">//没右子树，则找第一个当前节点是父节点左孩子的节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.next.left==node) <span class="keyword">return</span> node.next;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//退到了根节点仍没找到，则返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>











<blockquote>
<p><a href="https://www.cnblogs.com/zhi-leaf/p/10813048.html">https://www.cnblogs.com/zhi-leaf/p/10813048.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2020/07/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>二叉树的先序遍历，中序遍历，后序遍历，层次遍历,分层输出的层次遍历，递归与非递归方法</p>
<span id="more"></span>

<p><img src="/images/pasted-40.png" class="lazyload" data-srcset="/images/pasted-40.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> hs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">erchashu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        System.out.print(p.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeNode a = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">        TreeNode b = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">        TreeNode c = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode d = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        TreeNode e = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        TreeNode f = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        TreeNode g = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        a.left = b;</span><br><span class="line">        a.right = c;</span><br><span class="line">        b.right = d;</span><br><span class="line">        c.left = e;</span><br><span class="line">        c.right = f;</span><br><span class="line">        f.left = g;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;递归的先序遍历&quot;</span>);</span><br><span class="line">        recursivePreOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;递归的中序遍历&quot;</span>);</span><br><span class="line">        recursiveInOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;递归的后序遍历&quot;</span>);</span><br><span class="line">        recursiveLatOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;非递归的先序遍历&quot;</span>);</span><br><span class="line">        feidiguipreOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;非递归的中序遍历&quot;</span>);</span><br><span class="line">        feidiguiinOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;非递归的后序遍历&quot;</span>);</span><br><span class="line">        feidiguilatOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;非递归的后序遍历-1&quot;</span>);</span><br><span class="line">        feidiguilatOrder1(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;非递归的层次遍历-1&quot;</span>);</span><br><span class="line">        iterativeLevelOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;非递归的分层输出的层次遍历&quot;</span>);</span><br><span class="line">        iterlevelOrder(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;非递归的分层输出的层次遍历-1&quot;</span>);</span><br><span class="line">        iterlevelOrder1(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;分层份数组输出&quot;</span>);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = levelOrder(a);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**********递归的先序遍历**********</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursivePreOrder</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        visit(p);</span><br><span class="line">        recursivePreOrder(p.left);</span><br><span class="line">        recursivePreOrder(p.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**********递归的中序遍历**********</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveInOrder</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recursiveInOrder(p.left);</span><br><span class="line">        visit(p);</span><br><span class="line">        recursiveInOrder(p.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//****递归的后序遍历*******</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursiveLatOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123; <span class="keyword">return</span>;&#125;</span><br><span class="line">        recursiveLatOrder(p.left);</span><br><span class="line">        recursiveLatOrder(p.right);</span><br><span class="line">        visit(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//***非递归的先序遍历******</span></span><br><span class="line">    <span class="comment">//手算的思想，找到最左下方的，然后向上再向访问右边的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">feidiguipreOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//先序遍历父节点</span></span><br><span class="line">                visit(p);</span><br><span class="line">                <span class="comment">//把父节点存下来</span></span><br><span class="line">                st.push(p);</span><br><span class="line">                <span class="comment">//访问父节点的最左边节点</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果访问到叶子节点了，再返回最后一个父节点（该节点为栈顶元素）</span></span><br><span class="line">            p = st.pop();</span><br><span class="line">            <span class="comment">//访问父节点的右节点</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//***非递归的中序遍历******</span></span><br><span class="line">    <span class="comment">//手算的思想，找到最左下方的，然后向上再向访问右边的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">feidiguiinOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//先序遍历父节点</span></span><br><span class="line">                <span class="comment">//把父节点存下来</span></span><br><span class="line">                st.push(p);</span><br><span class="line">                <span class="comment">//访问父节点的最左边节点</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果访问到叶子节点了，再返回最后一个父节点（该节点为栈顶元素）</span></span><br><span class="line">            p = st.pop();</span><br><span class="line">            <span class="comment">//中序遍历父节点</span></span><br><span class="line">            visit(p);</span><br><span class="line">            <span class="comment">//访问父节点的右节点</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//***非递归的后序遍历******</span></span><br><span class="line">    <span class="comment">//手算的思想，找到最左下方的，然后向上再向访问右边的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">feidiguilatOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode prev = p;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty() || p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//先序遍历父节点</span></span><br><span class="line">                <span class="comment">//把父节点存下来</span></span><br><span class="line">                st.push(p);</span><br><span class="line">                <span class="comment">//访问父节点的最左边节点</span></span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//搜索到最左边的节点之后，访问最后一个父节点（栈顶元素）的右节点</span></span><br><span class="line">            p = st.peek().right;</span><br><span class="line">            <span class="comment">//如果栈顶元素的右节点为空或者已经visit，则按顺序访问栈顶节点</span></span><br><span class="line">            <span class="keyword">if</span>(p == <span class="keyword">null</span> || p == prev)&#123;</span><br><span class="line">                p = st.pop();</span><br><span class="line">                visit(p);</span><br><span class="line">                prev = p;</span><br><span class="line">                p = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右边的叶子节点会先入栈再出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**********非递归的后序遍历**********</span></span><br><span class="line">    <span class="comment">//双栈法，易于理解</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">feidiguilatOrder1</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; result = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() || p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//父节点存入栈中</span></span><br><span class="line">                stack.push(p);</span><br><span class="line">                result.push(p);</span><br><span class="line">                <span class="comment">//访问父节点的右节点</span></span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//上一个while访问到二叉树的最右节点，</span></span><br><span class="line">            <span class="comment">//if语句访问当前最右节点p的左节点，</span></span><br><span class="line">            <span class="comment">//并在下一轮循环中把该节点存入栈中</span></span><br><span class="line">            <span class="keyword">if</span> (!stack.empty()) </span><br><span class="line">              p = stack.pop().left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后从栈中取出所有节点</span></span><br><span class="line">        <span class="keyword">while</span> (!result.empty()) &#123;</span><br><span class="line">            p = result.pop();</span><br><span class="line">            visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**********非递归的层次遍历**********</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterativeLevelOrder</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            p = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) queue.offer(p.left);</span><br><span class="line">            <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">            visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//****非递归的分层输出的层次遍历***</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterlevelOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">            System.out.println(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)&#123;</span><br><span class="line">                p = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="keyword">null</span>) queue.offer(p.left);</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">                visit(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//***非递归的分层输出的层次病历-1**/</span></span><br><span class="line">    <span class="comment">//维护两个int，代表上一层和下一层的节点数量，</span></span><br><span class="line">    <span class="comment">//上一层遍历结束之后lineUp = lineDown; lineDown = 0;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterlevelOrder1</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> lineUp = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">int</span> lineDown = <span class="number">0</span>;</span><br><span class="line">        queue.offer(p);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            p = queue.poll();</span><br><span class="line">            visit(p);</span><br><span class="line">            <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(p.left);</span><br><span class="line">                lineDown++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                queue.offer(p.right);</span><br><span class="line">                lineDown++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(--lineUp == <span class="number">0</span>)&#123;</span><br><span class="line">                lineUp = lineDown;</span><br><span class="line">                lineDown = <span class="number">0</span>;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//****递归的层次病历访问****</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">diguilevelOrder</span><span class="params">(TreeNode p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">int</span> depth = maxDepth(p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= depth; i++) </span><br><span class="line">            visitNodeAtDepth(p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitNodeAtDepth</span><span class="params">(TreeNode p, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || depth &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//因为要按顺序访问（打印），所以要规定必须到某一层才能visit</span></span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">1</span>) &#123;</span><br><span class="line">            visit(p);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次都要遍历depth之上的所有层</span></span><br><span class="line">        visitNodeAtDepth(p.left, depth - <span class="number">1</span>);</span><br><span class="line">        visitNodeAtDepth(p.right, depth - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归方法得到树的层数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//层次遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode p) &#123;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(p);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> levelNum = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelNum; i++)&#123;</span><br><span class="line">                p = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(p.left != <span class="keyword">null</span>) queue.offer(p.left);</span><br><span class="line">                <span class="keyword">if</span>(p.right != <span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">                list.add(p.val);</span><br><span class="line">            &#125;</span><br><span class="line">            lists.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制位运算</title>
    <url>/2020/05/27/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="1-二进制中的负数"><a href="#1-二进制中的负数" class="headerlink" title="1. 二进制中的负数"></a>1. 二进制中的负数</h2><p>原码：一个整数按照绝对值的大小转化成二进制的数</p>
<p>反码：将二进制数按位取反</p>
<p>补码：反码加 1</p>
<p>负数：以正数的补码表示</p>
<span id="more"></span>


<p><strong>（1）机器都是使用补码，运算也是使用补码运算。</strong></p>
<p><strong>（2）正数的原码补码反码都一样。</strong></p>
<p><strong>（3）补码与原码相互转换，其运算过程是相同</strong></p>
<h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><p>1、定义：</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">名称</th>
<th align="center">实际操作</th>
<th align="center">简单记忆</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移</td>
<td align="center">2 进制左边补齐0位</td>
<td align="center">乘以2的N次方</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移</td>
<td align="center">2 进制右边减少位数</td>
<td align="center">除以2的N次方（其实并非如此，要舍去小数点）</td>
</tr>
<tr>
<td align="center">&lt;&lt;&lt;</td>
<td align="center">无符号右移</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><strong><em>java中 整数位 32位</em></strong></p>
<p>（1）左移：</p>
<p> 将一个运算对象的各二进制位全部左移若干位（左边的二进制丢弃，右边补0）</p>
<p><code>12 &lt;&lt; 2 = 48</code>    </p>
<p><code>-14 &lt;&lt;2 =-56</code></p>
<p>十进制运算方法：<br><code>12 * 2^2 = 48</code></p>
<p><code>-14 * 2^2 = -56</code></p>
<p>-14的左移操作</p>
<p>原码：          00000000  00000000  00000000  00001110</p>
<p>反码：          11111111  11111111  11111111  11110001</p>
<p>补码：          11111111 11111111  11111111  11110010</p>
<p>所以-14  的二进制是 11111111 11111111  11111111  11110010</p>
<p>左移两位  </p>
<p>补码：11111111 11111111  11111111  11001000</p>
<p>反码：11111111 11111111  11111111  11000111</p>
<p>原码： 00000000  00000000  00000000  00111000</p>
<p>源码代表56 因为有符号数，所以结果是-56</p>
<p>（2）右移：</p>
<p>将一个运算对象的各二进制位全部右移若干位，正数左补0，负数左补1.</p>
<p><code>4 &gt;&gt; 2 = 1</code></p>
<p><code>-14 &gt;&gt; 2 = -4</code></p>
<h2 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h2><h4 id="1、一位加法"><a href="#1、一位加法" class="headerlink" title="1、一位加法"></a><strong>1、一位加法</strong></h4><table>
<thead>
<tr>
<th>普通加法</th>
<th>异或</th>
</tr>
</thead>
<tbody><tr>
<td>1 + 1 = 0</td>
<td>1 ^ 1 = 0(错误)</td>
</tr>
<tr>
<td>1 + 0 = 1</td>
<td>1 ^ 0 = 1(正确)</td>
</tr>
<tr>
<td>0 + 1 = 1</td>
<td>0 ^ 1 = 1(正确)</td>
</tr>
<tr>
<td>0 + 0 = 0</td>
<td>0 ^ 0 = 0(正确)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">与运算</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1 &amp; 1 = 1(进位)</td>
</tr>
<tr>
<td align="center">1 &amp; 0 = 0(不进位)</td>
</tr>
<tr>
<td align="center">0 &amp; 1 = 0(不进位)</td>
</tr>
<tr>
<td align="center">0 &amp; 0 = 0(不进位)</td>
</tr>
</tbody></table>
<p>在位运算中，我们用“&lt;&lt;”表示向左移动一位，也就是“进位”。那么我们就可以得到如下的表达式</p>
<p><strong>( x &amp; y ) &lt;&lt; 1</strong> </p>
<p><strong>拥有了两个基本表达式：</strong></p>
<ul>
<li>执行加法   <strong>x ^ y</strong> </li>
<li>进位操作   <strong>( x &amp; y ) &lt;&lt; 1</strong></li>
</ul>
<h4 id="2、二位加法"><a href="#2、二位加法" class="headerlink" title="2、二位加法"></a>2、二位加法</h4><p>例子：</p>
<ul>
<li><p>*<em>正确的加法计算：11+01 = 100 *</em> </p>
</li>
<li><p>使用位运算实现二位加法：</p>
<ol>
<li>按位加法：      res1  = 11 ^ 01 = 10 </li>
<li>与运算进位：  res2 = (11 &amp; 01) &lt;&lt; 1 = ( 01 ) &lt;&lt; 1 = 010 </li>
<li>res1 ^ res2 = 10 ^ 010 = 00 </li>
<li>(10 &amp; 10) &lt;&lt; 1 = 100</li>
</ol>
</li>
</ul>
<h4 id="3、更高位的加法"><a href="#3、更高位的加法" class="headerlink" title="3、更高位的加法"></a>3、更高位的加法</h4><p>继续推理可以得出三位数的加法只需重复的计算三次得到第一个表达式的值就是计算出来的结果</p>
<p><strong>三位加法：</strong></p>
<ol>
<li><p>101 ^ 111 = 0010   （没有处理进位的加法）<br>(101 &amp; 111) &lt;&lt; 1 = 101 &lt;&lt; 1 = 1010  （此处得到哪一位需要加上进位，为1的地方表示有进位需要加上）</p>
</li>
<li><p>0010 ^ 1010 = 1000 （没有处理进位的加法 + 进位  = 没有处理进位的加法）</p>
<p>(0010 &amp; 1010) &lt;&lt; 1  = 0010 &lt;&lt; 1 = 00100 （查看是否有新的进位需要处理）</p>
</li>
<li><p>1000 ^ 00100 （没有处理进位的加法 + 进位 = 没有处理进位的加法）</p>
<p>(1000 &amp; 00100) &lt;&lt; 1 = 00000 &lt;&lt; 1 = 000000   (进位为0，所以没有要处理的进位了)</p>
</li>
</ol>
<blockquote>
<p><a href="https://www.jianshu.com/p/415412d99c76">https://www.jianshu.com/p/415412d99c76</a></p>
<p><a href="https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion">https://www.nowcoder.com/questionTerminal/59ac416b4b944300b617d4f7f111b215?answerType=1&amp;f=discussion</a></p>
</blockquote>
]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>二进制</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄漏</title>
    <url>/2020/09/11/%E5%86%85%E5%AD%98%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h3><p><code>内存泄漏：对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。</code></p>
<p>在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/54b5da7c6816">https://www.jianshu.com/p/54b5da7c6816</a></p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>内部类和外部类之间的相互调用</title>
    <url>/2020/07/22/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%A4%96%E9%83%A8%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/rgever/p/8902758.html">https://www.cnblogs.com/rgever/p/8902758.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h2 id="动态规划问题总结"><a href="#动态规划问题总结" class="headerlink" title="动态规划问题总结"></a>动态规划问题总结</h2><h3 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h3><p>1.递归方法：</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">solutionFibonace</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> solutionFibonacci(n-<span class="number">1</span>)+solutionFibonacci(n-<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态规划方法："><a href="#动态规划方法：" class="headerlink" title="动态规划方法："></a>动态规划方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solutionFibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> result[] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">			result[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">			result[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">				result[i] = result[i-<span class="number">1</span>] + result[i-<span class="number">2</span>];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result[n];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>与之类似的还有：</p>
<ul>
<li><p>跳台阶问题：每次只能跳一个或者两个台阶，跳到n层台阶上有几种方法</p>
</li>
<li><p>填充长方体问题：将一个2<em>1的长方体填充到2</em>n的长方体中，有多少种方法</p>
</li>
</ul>
<h3 id="2-数组最大不连续递增子序列"><a href="#2-数组最大不连续递增子序列" class="headerlink" title="2.数组最大不连续递增子序列"></a>2.数组最大不连续递增子序列</h3><p>arr[] = {3,1,4,1,5,9,2,6,5}的最长递增子序列长度为4。即为：1,4,5,9</p>
<p>（1）设置一个数组temp，长度为原数组长度，数组第i个位置上的数字代表0…i上最长递增子序列，</p>
<p>（2）当增加一个数字时，最大递增子序列可能变成前面最大的递增子序列+1，也可能就是前面最大递增子序列，</p>
<p>（3）这需要让新增加进来的数字arr[i]跟前面所有数字比较大小，</p>
<ul>
<li><p>当 arr[i] &gt; arr[j]，temp[i] = max{temp[j]}+1，其中，j 的取值范围为：0,1…i-1；</p>
</li>
<li><p>当 arr[i] &lt; arr[j]，temp[i] = max{temp[j]}，j 的取值范围为：0,1…i-1，</p>
<p> 所以状态转换方程为temp[i]=max{temp[i-1], temp[i-1]+1}</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MaxChildArrayOrder</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = a.length;</span><br><span class="line">	<span class="keyword">int</span> temp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//temp[i]代表0...i上最长递增子序列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		temp[i] = <span class="number">1</span>;<span class="comment">//初始值都为1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[j]&amp;&amp;temp[j]+<span class="number">1</span>&gt;temp[i])&#123;</span><br><span class="line">		    <span class="comment">//如果有a[i]比它前面所有的数都大，则temp[i]为它前面的比它小的数的那一个temp+1取得的最大值</span></span><br><span class="line">				temp[i] = temp[j]+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> max = temp[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//从temp数组里取出最大的值</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(temp[i]&gt;max)&#123;</span><br><span class="line">			max = temp[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-数组最大连续子序列和"><a href="#3-数组最大连续子序列和" class="headerlink" title="3.数组最大连续子序列和"></a>3.数组最大连续子序列和</h3><p> 如arr[] = {6,-1,3,-4,-6,9,2,-2,5}的最大连续子序列和为14。即为：9,2,-2,5</p>
<p>创建一个数组a，长度为原数组长度，不同位置数字a[i]代表0…i上最大连续子序列和，a[0]=arr[0]设置一个最大值max，初始值为数组中的第一个数字。当进来一个新的数字arr[i+1]时，判断到他前面数字子序列和sum+arr[i+1]跟arr[i+1]哪个大，<strong>前者大就保留前者，后者大就说明前面连续数字加起来都不如后者一个新进来的数字大，前面数字就可以舍弃</strong>，从arr[i+1]开始，每次比较完都跟max比较一下，最后的max就是最大值。<br>DP[i] = max{DP[i-1] + A[i],A[i]}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lianxuzixuliehe1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] a = &#123;<span class="number">6</span>,-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">4</span>,-<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,-<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> n = a.length;</span><br><span class="line">     <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> sum = a[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">         sum = Math.max(sum+a[i], a[i]);</span><br><span class="line">         <span class="keyword">if</span>(sum&gt;=max)&#123;</span><br><span class="line">             max = sum;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(max);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lianxuzixuliehe</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span>[] arr = &#123;<span class="number">6</span>,-<span class="number">1</span>,<span class="number">3</span>,-<span class="number">4</span>,-<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,-<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">     <span class="keyword">int</span> n = arr.length;</span><br><span class="line">     <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> sum = arr[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = sum + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; max) &#123;</span><br><span class="line">            max = sum;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(max);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2020/06/11/%E5%A0%86/</url>
    <content><![CDATA[<p>用堆来进行存储需要符合以下规则：</p>
<ul>
<li>1.元素可比较性：数据集中的元素可以进行比较，就是要实现Comparable接口；。</li>
<li>2.节点最大/最小性：每个节点的元素必须大于或小于该节点的孩子节点的元素；</li>
<li>3.堆是一棵完全二叉树。</li>
</ul>
<span id="more"></span>
<p>堆有两种：最大堆和最小堆。</p>
<p>最小堆中每个节点的优先级小于或者等于它的子节点；最大堆则相反，每个节点的优先级都大于或者等于它的子节点。</p>
<p>堆和普通树的区别<br>堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：</p>
<ul>
<li><p>节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</p>
</li>
<li><p>内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来村塾数组，且不使用指针。</p>
</li>
<li><p>平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。</p>
</li>
<li><p>搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p>
</li>
</ul>
<p>堆的大小是提前知道的，在java集合中堆是通过ArrayList数组实现的：</p>
<p>1.根节点位置：根节点的数据总是在数组的位置[0]</p>
<p>2.节点的父节点位置：假设一个非根节点的数据在数组中的位置[i]，那么它的父节点总是在位置[(i-1)/2]</p>
<p>3.节点的孩子节点位置：假设一个节点的数据在数组中的位置为[i]，那么它的孩子（如果有）总是在下面的这两个位置：左孩子在[2<em>i+1]，右孩子在[2</em>i+2]</p>
<blockquote>
<p><a href="https://blog.csdn.net/tuke_tuke/article/details/50357939">https://blog.csdn.net/tuke_tuke/article/details/50357939</a><br><a href="https://blog.csdn.net/tuke_tuke/article/details/50357939">https://blog.csdn.net/tuke_tuke/article/details/50357939</a><br><a href="https://www.jianshu.com/p/6b526aa481b1">https://www.jianshu.com/p/6b526aa481b1</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的操作</title>
    <url>/2020/06/11/%E5%A0%86%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的思路是这样的：</p>
<p>  当插入一个元素时，先将这个元素插入到队列尾，然后将这个新插入的元素和它的父节点进行优先权的比较，如果比父节点的优先权要大，则和父节点互换位置，然后再和新的父节比较，直到比新的父节点优先权小为止</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>字典序算法</title>
    <url>/2020/08/30/%E5%AD%97%E5%85%B8%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>字节跳动7.17面试</title>
    <url>/2020/07/17/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A87-17%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>字节跳动面试7.17</p>
<ol>
<li>自我介绍</li>
<li>哪个项目比较印象深刻</li>
<li>项目难点：我说了两个</li>
<li>你对面向对象的理解</li>
<li>说一下继承，封装，多态 </li>
<li>常用的设计模式？简单介绍一下你知道的几个？</li>
<li>hashmap 一次put的过程</li>
<li>哈希碰撞是什么？</li>
<li>哈希碰撞可以避免吗？</li>
<li>说一下快速排序的思想</li>
<li>快速排序的复杂度为什么是nlogn</li>
<li>算法题，{1,2,3,2,2,2,5,4,2} 类似数组，求个数多于数组长度一半的那个值，有则输出该值，没有则输出0</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>字节跳动面试</title>
    <url>/2020/07/01/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>1.自我介绍</p>
<p>2.做题</p>
<p>  给定[3,2,10,7,8,9]和target = 9 求出两个等于9的数的索引</p>
<p>  写完之后问你怎么优化？</p>
<p>3.索引—介绍一下mysql倒排索引</p>
<p>4.索引类型有哪几种？B树，字段可以不唯一的,</p>
<p>5.二叉树的搜索为什么比Btree的时间复杂度高，</p>
<p>6.https http差别，https加密在哪一层?(答错了，应该在第七层应用层)</p>
<p>7.听说过ssl TLS吗？</p>
<p>8.常用的加密算法</p>
<p>9.TCP三次握手</p>
<p>10.两次握手，可不可以？</p>
<p>11.操作系统了解些什么？cpu了解些什么？ 流水线，时间片</p>
<p>12.反问：基础薄弱，哪些地方可以加强。</p>
<p>前端要求？ 后台编程语言java，python</p>
<p>​    ES搜索、医学图像。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title>常用的加密算法</title>
    <url>/2020/07/17/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的异常和error</title>
    <url>/2020/09/24/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BC%82%E5%B8%B8%E5%92%8Cerror/</url>
    <content><![CDATA[<p>如下是常见的 Error 和 Exception：</p>
<p>1）运行时异常（RuntimeException）：</p>
<ul>
<li>NullPropagation：空指针异常；</li>
<li>ClassCastException：类型强制转换异常</li>
<li>IllegalArgumentException：传递非法参数异常</li>
<li>IndexOutOfBoundsException：下标越界异常</li>
<li>NumberFormatException：数字格式异常</li>
</ul>
<p>2）非运行时异常：</p>
<ul>
<li>ClassNotFoundException：找不到指定 class 的异常</li>
<li>IOException：IO 操作异常</li>
</ul>
<p>3）错误（Error）：</p>
<ul>
<li>NoClassDefFoundError：找不到 class 定义异常</li>
<li>StackOverflowError：深递归导致栈被耗尽而抛出的异常</li>
<li>OutOfMemoryError：内存溢出异常</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title> 强引用、弱引用、软引用和虚引用</title>
    <url>/2020/06/26/%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E5%92%8C%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>在JDK 1.2以前的版本中，若一个对象不被任何变量引用，那么程序就无法再使用这个对象。也就是说，只有对象处于(reachable)可达状态，程序才能使用它。</p>
<p>从JDK 1.2版本开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。</p>
<p>原文链接：<a href="https://blog.csdn.net/baidu_22254181/article/details/82555485">https://blog.csdn.net/baidu_22254181/article/details/82555485</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/06/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>十大排序算法<br><img src="/images/pasted-4.png" class="lazyload" data-srcset="/images/pasted-4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>图片名词解释：</p>
<ul>
<li>n: 数据规模</li>
<li>k: “桶”的个数</li>
<li>In-place: 占用常数内存，不占用额外内存</li>
<li>Out-place: 占用额外内存<span id="more"></span>

</li>
</ul>
<h3 id="1-排序的定义"><a href="#1-排序的定义" class="headerlink" title="1 排序的定义"></a>1 排序的定义</h3><p>对一序列对象根据某个关键字进行排序。</p>
<h3 id="2-术语说明"><a href="#2-术语说明" class="headerlink" title="2 术语说明"></a>2 术语说明</h3><ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ul>
<p><img src="/images/pasted-5.png" class="lazyload" data-srcset="/images/pasted-5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="3-比较和非比较的区别"><a href="#3-比较和非比较的区别" class="headerlink" title="3.比较和非比较的区别"></a>3.比较和非比较的区别</h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。<br>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均o(nlogn)。<br>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>
<p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p>
<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p>
<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
<p>插入排序</p>
<p>动图</p>
<p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="动图"></p>
<p>希尔排序</p>
<p><img src="/images/pasted-9.png" class="lazyload" data-srcset="/images/pasted-9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>归并排序</p>
<p><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="图示"></p>
<p>快速排序<br><img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" class="lazyload" data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="快速排序"></p>
<blockquote>
<p><a href="https://www.cnblogs.com/guoyaohua/p/8600214.html">https://www.cnblogs.com/guoyaohua/p/8600214.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排查内存溢出的原因</title>
    <url>/2020/09/24/%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8E%9F%E5%9B%A0/</url>
    <content><![CDATA[<p>1.检查是否使用过多static修饰<br>2.检查递归和循环</p>
<p>使用jconsole</p>
]]></content>
  </entry>
  <entry>
    <title>搜索引擎评估</title>
    <url>/2020/12/28/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<p>传统信息检索中，使用查全率，查准率。</p>
<p>对于搜索引擎来说需要满足：</p>
<ul>
<li>覆盖率</li>
<li>返回结果的准确性</li>
<li>重复信息过滤返回</li>
<li>网页更新速度</li>
<li>响应时间</li>
<li>系统稳定性</li>
</ul>
<p>Ranking模型的训练数据主要由query、文档以及query与文档的相关度组成，相关度可以标记成好、不好两个级别或细粒度更高的Perfect、Excellent、Good、Fair、Bad五个级别。</p>
<h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><h3 id="查全率"><a href="#查全率" class="headerlink" title="查全率"></a>查全率</h3><h3 id="查准率"><a href="#查准率" class="headerlink" title="查准率"></a>查准率</h3><h3 id="DCG"><a href="#DCG" class="headerlink" title="DCG"></a>DCG</h3><p><img src="/images/pasted-140.png" class="lazyload" data-srcset="/images/pasted-140.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>CG的思想是逐条对搜索结果进行分等级的打分，分越高越好</p>
<p>DCG的思想是DCG的思想是等级比较高的结果却排到了比较后面，那么在统计分数时，就应该对这个结果的得分有所打折。</p>
<p><img src="/images/pasted-141.png" class="lazyload" data-srcset="/images/pasted-141.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p>nDCG</p>
<p><img src="/images/pasted-142.png" class="lazyload" data-srcset="/images/pasted-142.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="WTA-MRR-MAP"><a href="#WTA-MRR-MAP" class="headerlink" title="WTA,MRR,MAP"></a>WTA,MRR,MAP</h3><p>1) WTA(Winners take all) 对于给定的查询q，如果模型返回的结果列表中，第一个文档是相关的，则WTA(q)=1，否则为0.</p>
<p>2) MRR(Mean Reciprocal Rank) 对于给定查询q，如果第一个相关的文档位置是R(q)，则MRR(q)=1/R(q)。</p>
<p>3) MAP(Mean Average Precision) 对于每个真实相关的文档d，考虑其在模型排序结果中的位置P(d)，统计该位置之前文档集合的分类准确率，取所有这些准确率的平均值。</p>
<h3 id="A-B-test"><a href="#A-B-test" class="headerlink" title="A/B test"></a>A/B test</h3><p>上线测试两个版本，比较两个版本的点击率，留存率，点击时长等</p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>基于图的。</p>
<p>基于MapReduce的微博用户搜索排名算法<br>主要思想：采用全体用户投票的方式来决定每个用户在搜索结果中的排名, 投票结果被量化成用户的“重要性”, 而用户的“重要性”则成为整个算法的排名依据。</p>
<p>单独标注一个或几个和心血管疾病比较相关的词，标5个重要性，然后计算上述指标。</p>
<p><img src="/images/pasted-143.png" class="lazyload" data-srcset="/images/pasted-143.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<blockquote>
<p>搜索引擎评价体系应该分几个方面？建立怎样的指标？ - ArayS的回答 - 知乎<br><a href="https://www.zhihu.com/question/19624746/answer/12578436">https://www.zhihu.com/question/19624746/answer/12578436</a></p>
</blockquote>
]]></content>
      <categories>
        <category>毕设</category>
        <category>搜索引擎</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的分页机制</title>
    <url>/2020/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>wsl2文件系统性能</title>
    <url>/2020/07/15/%E6%9C%AA%E6%94%B6%E5%BD%95/</url>
    <content><![CDATA[<p>wsl2 跨OS的文件系统较差，搭建博客可以考虑把博客文件全部放在wsl2的根目录下：<br><code>\\wsl$\Ubuntu-20.04\home\huanshi2</code></p>
<p>感觉速度快了三四倍</p>
<span id="more"></span>
<p><img src="/images/pasted-46.png" class="lazyload" data-srcset="/images/pasted-46.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<blockquote>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/compare-versions">https://docs.microsoft.com/zh-cn/windows/wsl/compare-versions</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Wsl2</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>wsl2</tag>
      </tags>
  </entry>
  <entry>
    <title>标注中出现的一些问题</title>
    <url>/2020/05/30/%E6%A0%87%E6%B3%A8%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-过敏史"><a href="#1-过敏史" class="headerlink" title="1.过敏史"></a>1.过敏史</h3><p>过敏史不需要标最后的“史”字，尽量不标注标点符号</p>
<p>否认药物食物过敏  食物、药物过敏</p>
<p>如果是在一句话中，直接全部标注</p>
<span id="more"></span>

<h3 id="2-否认"><a href="#2-否认" class="headerlink" title="2.否认"></a>2.否认</h3><p>否认直接标否认</p>
<h3 id="3-结果"><a href="#3-结果" class="headerlink" title="3.结果"></a>3.结果</h3><p>已治愈 标注为结果</p>
<h3 id="4-时间"><a href="#4-时间" class="headerlink" title="4.时间"></a>4.时间</h3><p>30年前 标注要加前</p>
<p>术后一周全标</p>
<h3 id="5-既往用药"><a href="#5-既往用药" class="headerlink" title="5.既往用药"></a>5.既往用药</h3><p>不标用量</p>
<h3 id="6-病情"><a href="#6-病情" class="headerlink" title="6.病情"></a>6.病情</h3><p>普通的描述句子不标注</p>
<p><img src="/images/pasted-3.png" class="lazyload" data-srcset="/images/pasted-3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"><br>这种尽量标注</p>
<h3 id="7-辅助检查"><a href="#7-辅助检查" class="headerlink" title="7.辅助检查"></a>7.辅助检查</h3><p>检查项目和结果都标出来</p>
<p>最高，最低都标注</p>
<h3 id="8-外伤史"><a href="#8-外伤史" class="headerlink" title="8.外伤史"></a>8.外伤史</h3><p>疤痕也要标</p>
<p>摔倒不标，标盆骨破裂</p>
<h3 id="9-手术史"><a href="#9-手术史" class="headerlink" title="9.手术史"></a>9.手术史</h3><p>更换起搏器也算手术史，不要漏标</p>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>数据标注</tag>
      </tags>
  </entry>
  <entry>
    <title>判断字符串是否表示数值</title>
    <url>/2020/06/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<span id="more"></span>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/6f8c901d091949a5837e24bb82a731f2?answerType=1&amp;f=discussion">https://www.nowcoder.com/questionTerminal/6f8c901d091949a5837e24bb82a731f2?answerType=1&amp;f=discussion</a><br>来源：牛客网</p>
<p><code>^</code>和 美元符号框定正则表达式，它指引这个正则表达式对文本中的所有字符都进行匹配。</p>
<ul>
<li>如果省略这些标识，那么只要一个字符串中包含一个数字这个正则表达式就会进行匹配。</li>
<li>如果仅包含 ^ ，它将匹配以一个数字开头的字符串。如果仅包含$ ，则匹配以一个数字结尾的字符串。</li>
</ul>
<p><code>[-+]?</code></p>
<p>正负号后面的 ? 后缀表示这个负号是可选的,表示有0到1个负号或者正号</p>
<p><code>\\d*</code></p>
<p><code>\</code>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。<code>\d</code>的含义和[0-9]一样。它匹配一个数字。后缀 * 指引它可匹配零个或者多个数字。</p>
<p><code>(?:\\.\\d*)?</code></p>
<p><code>(?: …)</code>表示一个可选的非捕获型分组。* 指引这个分组会匹配后面跟随的0个或者多个数字的小数点。<br><code>?</code>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 <code>\?</code>。<br><code>(?:[eE][+\\-]?\d+)?</code></p>
<p>这是另外一个可选的非捕获型分组。它会匹配一个e(或E)、一个可选的正负号以及一个或多个数字。</p>
<p><code>&#123;&#125;</code>一般是用来匹配的长度</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入URL后发生了什么？</title>
    <url>/2020/08/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<ol>
<li>DNS域名解析</li>
<li>建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求</li>
<li>服务器返回响应结果</li>
<li>关闭TCP连接</li>
<li>浏览器解析HTML</li>
<li>浏览器渲染布局<span id="more"></span>
<h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2>浏览器项本地DNS服务器发起请求，采用迭代查询的方式依次向根域名服务器，顶级域名服务器，权威域名服务器发起查询请求，直到查到一个或一组IP地址返回给浏览器。<h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2>通过 DNS 解析拿到服务器 IP 地址后，浏览器再通过系统调用 Socket 接口与服务器 443 端口进行通信，整个过程可以分解为建立连接、发送 HTTP 请求、返回 HTTP 响应、维持连接、释放连接五个部分。<h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2>浏览器开始发送 HTTP 请求，一个请求报文由请求行、请求头、空行、实体（Get 请求没有）组成。<h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2></li>
</ol>
<h2 id="服务器返回响应结果"><a href="#服务器返回响应结果" class="headerlink" title="服务器返回响应结果"></a>服务器返回响应结果</h2><p>服务器接受并处理完请求，返回 HTTP 响应，一个响应报文格式基本等同于请求报文，由响应行、响应头、空行、实体组成。</p>
<h3 id="维持连接"><a href="#维持连接" class="headerlink" title="维持连接"></a>维持连接</h3><p>完成一次 HTTP 请求后，服务器并不是马上断开与客户端的连接。在 HTTP/1.1 中，Connection: keep-alive 是默认启用的，表示持久连接，以便处理不久后到来的新请求，无需重新建立连接而增加慢启动开销，提高网络的吞吐能力。在反向代理软件 Nginx 中，持久连接超时时间默认值为 75 秒，如果 75 秒内没有新到达的请求，则断开与客户端的连接。同时，浏览器每隔 45 秒会向服务器发送 TCP keep-alive 探测包，来判断 TCP 连接状况，如果没有收到 ACK 应答，则主动断开与服务器的连接。注意，HTTP keep-alive 和 TCP keep-alive 虽然都是一种保活机制，但是它们完全不相同，一个作用于应用层，一个作用于传输层。</p>
<h2 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h2><h2 id="浏览器解析HTML"><a href="#浏览器解析HTML" class="headerlink" title="浏览器解析HTML"></a>浏览器解析HTML</h2><h2 id="浏览器渲染布局"><a href="#浏览器渲染布局" class="headerlink" title="浏览器渲染布局"></a>浏览器渲染布局</h2><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43369093">https://zhuanlan.zhihu.com/p/43369093</a></p>
</blockquote>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝和浅拷贝</title>
    <url>/2020/08/27/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p><a href="https://segmentfault.com/a/1190000010648514">https://segmentfault.com/a/1190000010648514</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
        <tag>浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>医学知识图谱</title>
    <url>/2020/05/28/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<h2 id="构建医学知识图谱"><a href="#构建医学知识图谱" class="headerlink" title="构建医学知识图谱"></a>构建医学知识图谱</h2><p>本系统在开发过程中，涉及到的技术与框架繁多，为了使各个业务系统分离，使用微服务架构，为了进一步提高系统并发量与高可用，使用分布式技术。系统架构如图六所示：</p>
<span id="more"></span>
<p><img src="https://wx1.sbimg.cn/2020/05/28/clip_image012.jpg" class="lazyload" data-srcset="https://wx1.sbimg.cn/2020/05/28/clip_image012.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="clip_image012.jpg"></p>
<p>(1)针对支撑知识图谱的Neo4j数据库、支撑快速检索医学词典的Elastic Search数据库与提供医学知识库的MySQL数据库，为了进一步提升三个数据库的读写能力，使用分布式架构，将三者有关的功能模块进行分离。</p>
<p>(2)在系统的前后端分离上，使用Nginx服务器进行静态资源的读写，进一步提升系统的吞吐等待量与高可用。</p>
<p>(3)使用Spring Cloud框架用于分离各个系统功能模块，便于后续系统的升级与维护。</p>
<p>  知识图谱可以大致概括为节点与关系的组成图谱，非常有助于本项目对医疗数据的分析与研究。关于知识图谱的节点设计，我们抽取医疗知识库中的全部症状词与全部疾病词构成了知识图谱的全部节点，这部分数据也成为了本项目的医学词典。每个节点都有许多属性，包括科室、症状、病因、并发症、治疗、预防等，但这些属性都是以长文本的形式存储，医学命名实体并没有被单独标注区分。前面已经说明，研究的主要方向是针对疾病与症状的联系，我们利用医学词典对疾病的症状属性进行分词。由此症状节点与疾病节点有了直接的关联，此时的节点知识图谱如图二所示：</p>
<p><img src="https://wx2.sbimg.cn/2020/05/28/clip_image004.jpg" class="lazyload" data-srcset="https://wx2.sbimg.cn/2020/05/28/clip_image004.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="clip_image004.jpg"></p>
<p>  当每个疾病节点都与它所属的症状或一些并发症进行了关联之后，相互之间难免出现交叉。以图二所示举例，偏头痛会导致一系列症状与并发症，这种关系以箭头指向表示，偏头痛指向丛集性头痛，丛集性头痛又指向症状词头痛，偏头痛也指向了头痛，各种复杂的疾病、症状关系正是通过这种复杂的指向关系（也就是知识图谱），进行了清晰的展示。</p>
<blockquote>
<p><a href="https://github.com/ystcode/Doctor">https://github.com/ystcode/Doctor</a></p>
</blockquote>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱参考</title>
    <url>/2020/05/28/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/37057052">https://zhuanlan.zhihu.com/p/37057052</a></p>
</blockquote>
<p>建设一个知识图谱系统，需要包括：知识建模、知识获取、知识融合、知识存储和知识应用5大部分：</p>
<p>1、知识建模：构建多层级知识体系，将抽象的知识、属性、关联联关系等信息，进行定义、组织、管理，转化成现实的数据库。</p>
<span id="more"></span>
<p>2、知识获取：将不同来源、不同结构的数据转化成图谱数据，包括结构化数据、半结构化数据（解析）、知识标引、知识推理等，保障数据的有效性和完整性。</p>
<p>3、知识融合：将多个来源、重复的知识信息进行融合，包括融合计算、融合计算引擎、手动操作融合等。</p>
<p>4、知识存储：根据业务场景提供合理的知识存储方案，存储方案具备灵活、多样化、可拓展特性。</p>
<p>5、知识应用：为已构建知识图谱提供图谱检索、知识计算、图谱可视化等分析与应用能力。并提供各类知识计算的SDK，包含图谱基础应用类、图结构分析类、图谱语义应用类、自然语言处理类、图数据获取类、图谱统计类、数据集数据获取类、数据集统计类。</p>
<p>结构化新冠知识图谱</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/143956563">https://zhuanlan.zhihu.com/p/143956563</a></p>
</blockquote>
<p>搜索中的Query扩展技术</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/138551957">https://zhuanlan.zhihu.com/p/138551957</a></p>
</blockquote>
<h1 id="知识图谱的三大典型应用"><a href="#知识图谱的三大典型应用" class="headerlink" title="知识图谱的三大典型应用"></a>知识图谱的三大典型应用</h1><p>知识图谱的典型应用包括语义搜索、智能问答以及可视化决策支持三种。</p>
<p>1、语义搜索</p>
<p>当前基于关键词的搜索技术在知识图谱的知识支持下可以上升到基于实体和关系的检索，称之为语义搜索。</p>
<p>语义搜索可以利用知识图谱可以准确地捕捉用户搜索意图，进而基于知识图谱中的知识解决传统搜索中遇到的关键字语义多样性及语义消歧的难题，通过实体链接实现知识与文档的混合检索。</p>
<p>语义检索需要考虑如何解决自然语言输入带来的表达多样性问题，同时需要解决语言中实体的歧义性问题。同时借助于知识图谱，语义检索需要直接给出满足用户搜索意图的答案，而不是包含关键词的相关网页的链接。</p>
<p>2、智能问答</p>
<p>问答系统（Question Answering，QA）是信息服务的一种高级形式，能够让计算机自动回答用户所提出的问题。不同于现有的搜索引擎，问答系统返回用户的不再是基于关键词匹配的相关文档排序，而是精准的自然语言形式的答案。</p>
<p>智能问答系统被看作是未来信息服务的颠覆性技术之一，亦被认为是机器具备语言理解能力的主要验证手段之一。</p>
<p>智能问答需要针对用户输入的自然语言进行理解，从知识图谱中或目标数据中给出用户问题的答案，其关键技术及难点包括准确的语义解析、正确理解用户的真实意图、以及对返回答案的评分评定以确定优先级顺序。</p>
<p>3、可视化决策支持</p>
<p>可视化决策支持是指通过提供统一的图形接口，结合可视化、推理、检索等，为用户提供信息获取的入口。例如，决策支持可以通过图谱可视化技术对创投图谱中的初创公司发展情况、投资机构投资偏好等信息进行解读，通过节点探索、路径发现、关联探寻等可视化分析技术展示公司的全方位信息。</p>
<p>可视化决策支持需要考虑的关键问题包括通过可视化方式辅助用户快速发现业务模式、提升可视化组件的交互友好程度、以及大规模图环境下底层算法的效率等。</p>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title>类的内存分配过程</title>
    <url>/2020/06/29/%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h2><p>Person.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;我正在走路....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>测试类Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.name = <span class="string">&quot;java开发工程师&quot;</span>;</span><br><span class="line">      person.age = <span class="number">24</span>;</span><br><span class="line">      person.walk; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li><p>第一步，jvm去方法去寻找test类的代码信息，如果有则直接调用，没有的话使用类的加载机制把类加载进来。同时把<strong>静态变量</strong>，<strong>静态方法</strong>，<strong>常量</strong>和<strong>全局变量</strong>加载进来。</p>
</li>
<li><p>第二步，jvm进入<code>main</code>方法区，看到看到<code>Person person=new Person()</code>，首先分析方法区是否有<code>Person</code>类的代码信息，有就加载，没有的话类加载机制加载进来。同时加载静态变量，静态方法，常量。</p>
</li>
<li><p>第三步，jvm接下来看到<code>Person person</code> 在main方法内部，此时<code>person</code>是局部变量，存放在栈空间中。此时地址还没有存储后面的<code>new Person()</code>地址。</p>
</li>
<li><p>第四步，jvm接下来看到了<code>new Person()</code>。 new出的对象<strong>实例</strong>存在堆空间中</p>
</li>
<li><p>第五步，jvm接下来看到了 <code>=</code> ,把<code>new Person()</code>的地址告诉<code>person</code>变量，这样栈中的<code>person</code>变量的值就修改为<code>new Person()</code>的地址。<code>person</code>通过地址引用该实例,效果如下图。</p>
</li>
</ol>
<p><img src="/images/pasted-21.png" class="lazyload" data-srcset="/images/pasted-21.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<ol start="6">
<li><p>第六步，jvm看到 <code>person.name = &quot;冯东东的IT技术栈&quot;</code>,<code>person</code>通过引用 <code>new Person</code>实例的<code>name</code>属性，该属性通过地址指向常量池的”冯东东的IT技术栈”</p>
</li>
<li><p>第七步, jvm看到<code>person.age = 18</code>; <code>person</code> 的<code>age</code>属性是基本数据类型，直接赋值。</p>
</li>
<li><p>第八步，jvm看到<code>person.walk()</code>,调用实例方法时，并不会在实例对象中生产一个新方法，而是通过地址指向方法曲中的类信息中的方法</p>
</li>
</ol>
<p><img src="/images/pasted-22.png" class="lazyload" data-srcset="/images/pasted-22.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存分配</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池的原理</title>
    <url>/2020/08/30/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/fuyuwei2015/article/details/72758179">https://blog.csdn.net/fuyuwei2015/article/details/72758179</a></p>
</blockquote>
<blockquote>
<p><a href="https://juejin.im/post/6844903602452955150">https://juejin.im/post/6844903602452955150</a></p>
</blockquote>
<p>写一个简单的线程池</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/2020/06/05/%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>计算机系统会使用缓存技术来组织内存，访问数组相邻的元素会比访问不相邻的元素快很多。</p>
<span id="more"></span>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转二叉树</title>
    <url>/2020/08/30/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/09/02/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://blog.csdn.net/yandaoqiusheng/article/details/84782655">https://blog.csdn.net/yandaoqiusheng/article/details/84782655</a></p>
</blockquote>
<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p><img src="/images/pasted-78.png" class="lazyload" data-srcset="/images/pasted-78.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>有<code>N</code>件物品和一个容量为<code>V</code>的背包。第<code>i</code>件物品的费用是<code>w[i]</code>，价值是<code>v[i]</code>，求将哪些物品装入背包可使价值总和最大。</p>
<span id="more"></span>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。<br>用子问题定义状态：即<code>f[i][j]</code>表示前<code>i</code>件物品恰放入一个容量为<code>j</code>的背包可以获得的最大价值。则其状态转移方程便是：</p>
<p><img src="/images/pasted-78.png" class="lazyload" data-srcset="/images/pasted-78.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="upload successful"></p>
<p><code>f[i][j]=max(f[i−1][j],f[i−1][j−w[i]]+v[i])</code></p>
<p>i表示前i件物品，j表示剩余容量</p>
<p><strong>“将前<code>i</code>件物品放入容量为jj的背包中”这个子问题，若只考虑第ii件物品的策略（放或不放），那么就可以转化为一个只牵扯前<code>i−1</code>件物品的问题。如果不放第<code>i</code>件物品，那么问题就转化为“前<code>i−1</code>件物品放入容量为<code>j</code>的背包中”，价值为<code>f[i−1][j]</code>；如果放第<code>i</code>件物品，那么问题就转化为“前<code>i−1</code>件物品放入剩下的容量为<code>j−w[i]</code>的背包中”，此时能获得的最大价值就是<code>f[i−1][j−w[i]]</code>再加上通过放入第ii件物品获得的价值<code>v[i]</code>。</strong></p>
<ol>
<li>如果不放第i件物品， 则最大价值为<code>f[i-1][j]</code></li>
<li>如果放第i件物品，前i-1件物品价值为<code>f[i-1][j-v[i]]</code>,再加上第i件物品价值，则最大价值为 <code>f[i-1][j-w[i]] + v[i]</code></li>
</ol>
<h3 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0-1背包问题</span></span><br><span class="line"><span class="comment">每类物品最多装一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> V = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span>[] weight = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            value[i] = sc.nextInt();</span><br><span class="line">            weight[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        sc.close();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight[i - <span class="number">1</span>] &gt; j) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(j - weight[i - <span class="number">1</span>] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int[] dp = new int[V + 1];</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; N; i++) &#123;</span></span><br><span class="line">        <span class="comment">// for (int j = V; j &gt;= 0; j--) &#123;</span></span><br><span class="line">        <span class="comment">// if (j &gt; weight[i]) &#123;</span></span><br><span class="line">        <span class="comment">// dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// int[] dp = new int[V + 1];</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; N; i++) &#123;</span></span><br><span class="line">        <span class="comment">// for (int j = weight[i]; j &lt; V + 1; j++) &#123;</span></span><br><span class="line">        <span class="comment">// dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] b : dp) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c : b)&#123;</span><br><span class="line">                System.out.print(c + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> maxValue = dp[N][V];</span><br><span class="line">        System.out.println(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 10</span><br><span class="line">5 4</span><br><span class="line">5 3</span><br><span class="line">10 4</span><br><span class="line">8 6</span><br><span class="line">4 2</span><br><span class="line">-----------</span><br><span class="line">0 1 2 3 4 5 6</span><br><span class="line">0 1 2 3 4 5 6 7</span><br><span class="line">0 1 2 3 4 5 6</span><br><span class="line">0 1 2 3 4</span><br><span class="line">0 1 2 3 4 5 6 7 8</span><br><span class="line">-----------</span><br><span class="line">0 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 5 5 5 5 5 5 5</span><br><span class="line">0 0 0 5 5 5 5 10 10 10 10</span><br><span class="line">0 0 0 5 10 10 10 15 15 15 15</span><br><span class="line">0 0 0 5 10 10 10 15 15 15 18</span><br><span class="line">0 0 4 5 10 10 14 15 15 19 19</span><br><span class="line">-----------</span><br><span class="line">19</span><br></pre></td></tr></table></figure>
<p>第二部分表示用于迭代计算的上一部分的值的容量<code>j</code></p>
<p><strong>第一行</strong></p>
<p>表示容量从0到10的情况下一个物品都不拿的情况，所以最后不管容量为多少，最大价值都为0.</p>
<p><code>dp[0][j] = 0</code></p>
<p><strong>第二行</strong></p>
<ul>
<li><p>表示容量从0-10的情况下只拿第一个物品或者不拿第一个物品的情况，由于第一件物品占用容量为4，<code>weight[0] = 4 &gt; j</code>，<code>j</code>在0-3之间时，容量均小于第一件物品占用容量4，所以<code>dp[0][j]</code>始终为0。</p>
</li>
<li><p>当容量大于等于4时，此时需要考虑第一件物品的价值。第一件物品的价值为5，容量为4，所以容量变大到4以后，计算 <strong><code>dp[1][j] = Math.max(dp[0][j], dp[0][j - weight[0]] + value[0])</code></strong> ,可以看出这一行的值使用了第一行的值。</p>
</li>
</ul>
<p><strong>第三行</strong></p>
<ul>
<li><p>表示容量从0-10的情况下，可以从第一，第二件物品中选择的过程，第二件物品占用容量比第一件物品小，由于第二件物品占用容量为3，<code>weight[1] = 3 &gt; j</code>，容量在0-2之间，放不下第二件物品，所以dp为0</p>
</li>
<li><p>当容量大于等于3时，<code>dp[2][3] = Math.max(dp[1][3], dp[1][3 - weight[1]] + value[1])</code>,容量<code>j = 4</code>时，<code>dp[2][4] = Math.max(dp[1][4], dp[1][4 - weight[1]] + value[1])</code>, 容量<code>j</code>从4到6之间，只能放下第一个物品和第二个物品两个中的一个，但是两个物品价值相同，所以最大价值一直为5。当<code>j = 7</code>时，<code>dp[2][7] = Math.max(dp[1][7], dp[1][7-weight[1]] + value[1])</code>. 即求两个物品最大价值时，可以把两个物品分开，先计算去掉当前物品容量的情况下的最大价值，再加上当前物品的价值，最后比较加了该物品和未加该物品，当前容量减掉当前物品容量的情况可以在数组中前一行找到。</p>
</li>
</ul>
<p>其他行同理。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式之工厂模式</title>
    <url>/2020/09/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符</title>
    <url>/2020/07/09/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>按位与运算符（&amp;）</td>
<td>二进制位与运算，串联电路</td>
<td><code>0&amp;0=0; 0&amp;1=0;  1&amp;0=0;  1&amp;1=1;</code></td>
</tr>
<tr>
<td>异或运算符“^”</td>
<td>用于位运算，每个位相同为0，不同为1</td>
<td><code>0 ^1 =1， 0 ^ 0 = 0；1^0=1, 1^1=0;</code></td>
</tr>
<tr>
<td>取反运算符（~）</td>
<td>按位取反</td>
<td>~1=0； ~0=1；</td>
</tr>
<tr>
<td>位移运算符“&lt;&lt;”和”&gt;&gt;”</td>
<td>移位</td>
<td>1&lt;&lt;2 = 4</td>
</tr>
<tr>
<td>条件运算符 ？</td>
<td></td>
<td><code>int result = 1 &gt; 2 ? 1 + 1 : 2 + 2;          //   result = 4;</code></td>
</tr>
</tbody></table>
<p>| 按位或运算符（|）   | 二进制位或运算，并联电路           | <code>0|0=0，0|1=1；1|0=1，1|1=1；</code> |</p>
<span id="more"></span>

<h3 id="amp-amp-和-amp"><a href="#amp-amp-和-amp" class="headerlink" title="&amp;&amp; 和 &amp;"></a>&amp;&amp; 和 &amp;</h3><p>&amp;&amp;有短路功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i++&amp;&amp;j++)</span><br><span class="line"></span><br><span class="line">System.out.println(“j=”+j);</span><br></pre></td></tr></table></figure>
<p>&amp;&amp;输出结果为<code>j=1</code></p>
<p>&amp;输出结果为<code>j=2</code></p>
<p>||  表示短路或，|  表示不短路或</p>
<p>或运算只要一个为true，那么结果就为true</p>
]]></content>
      <categories>
        <category>运算符</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信的7种方式</title>
    <url>/2020/08/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></p>
</blockquote>
<h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><ol>
<li>管道/匿名管道(pipe) 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。 …</li>
<li>有名管道(FIFO) …</li>
<li>信号(Signal) …</li>
<li>消息(Message)队列 …</li>
<li>共享内存(share memory) …</li>
<li>信号量(semaphore) …</li>
<li>套接字(socket)</li>
</ol>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用java restclient API 操作Elasticsearch</title>
    <url>/2020/05/27/%E4%BD%BF%E7%94%A8java-restclient-API-%E6%93%8D%E4%BD%9CElasticsearch/</url>
    <content><![CDATA[<h1 id="使用Java操作Elasticsearch-6-8-4"><a href="#使用Java操作Elasticsearch-6-8-4" class="headerlink" title="使用Java操作Elasticsearch-6.8.4"></a>使用Java操作Elasticsearch-6.8.4</h1><h2 id="1-确定elasticsearch是否已经在本机运行"><a href="#1-确定elasticsearch是否已经在本机运行" class="headerlink" title="1. 确定elasticsearch是否已经在本机运行"></a>1. 确定elasticsearch是否已经在本机运行</h2><p>在浏览器中输入<code>http://localhost:9200/</code>查看elasticsearch是否成功运行</p>
<span id="more"></span>
<p><img src="https://img-blog.csdnimg.cn/20200503162853650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200503162853650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>如果出现如上图结果，则说明elasticsearch成功运行在本机，如果没有出现上图结果，可以先检查elsaticsearch开发环境。</p>
<h2 id="2-搭建maven工程，添加依赖"><a href="#2-搭建maven工程，添加依赖" class="headerlink" title="2. 搭建maven工程，添加依赖"></a>2. 搭建maven工程，添加依赖</h2><p>pom.xml文件配置如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>EHRelasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- elasticsearch的客户端 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.8.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- elasticsearch依赖2.x的log4j --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- junit单元测试 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中<code>elasticsearch</code>的版本为<code>6.8.4</code></p>
<p><code>junit</code>依赖：</p>
<pre><code>Junit是xUnit的一个子集，在c++,paython,java语言中测试框架的名字都不相同，xUnit是一套基于测试驱动开发的测试框架。
其中的断言机制：将程序预期的结果与程序运行的最终结果进行比对，确保对结果的可预知性。</code></pre><blockquote>
<p><a href="https://blog.csdn.net/fulishafulisha/article/details/80158392">https://blog.csdn.net/fulishafulisha/article/details/80158392</a></p>
</blockquote>
<p>直接引用csdn博主fulisha_la的总结：<br>修饰符及其作用：</p>
<blockquote>
<ul>
<li>@BeforeClass<br>修饰的方法会在所有方法被调用前执行，且该方法时静态的，所以当测试类被加载后就接着运行它，而且在内存中他只会存在一份实例，他比较适合加载配置文件（针对所有测试，只执行一次 </li>
<li>@AfterClass<br>所修饰的方法通常用来对资源管理，如关闭数据库连接（针对所有测试，只执行一次 ）</li>
<li>@Before和@After 会在每个测试方法前后各执行一次</li>
<li>@Test：测试方法，在这里可以测试期望异常和超时时间</li>
<li>@Ignore：忽略的测试方法  </li>
</ul>
</blockquote>
<h2 id="3-Java操作elasticsearch"><a href="#3-Java操作elasticsearch" class="headerlink" title="3. Java操作elasticsearch"></a>3. Java操作elasticsearch</h2><p>直接上代码，连接es后再查找一条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.get.GetResponse;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.transport.TransportAddress;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.transport.client.PreBuiltTransportClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: EHRelasticsearch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 使用java连接elasicsearch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: huanshi2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-04-30 18:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: 1557679224@qq.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectEs</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置集群名称elasticsearch-cluster,Settings设置es的集群名称,使用的设计模式，链式设计模式、build设计模式。</span></span><br><span class="line">            Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;elasticsearch-cluster&quot;</span>).build();</span><br><span class="line">            <span class="comment">// 读取es集群中的数据,创建client。</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">            TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings).addTransportAddresses(</span><br><span class="line">                    <span class="keyword">new</span> TransportAddress(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">9300</span>));</span><br><span class="line">            <span class="comment">// 搜索数据(.actionGet()方法是同步的，没有返回就等待)</span></span><br><span class="line">            <span class="comment">// 方式是先去索引里面查询出索引数据,再去文档里面查询出数据。</span></span><br><span class="line">            GetResponse response = client.prepareGet(<span class="string">&quot;emr&quot;</span>, <span class="string">&quot;patient&quot;</span>, <span class="string">&quot;1&quot;</span>).execute().actionGet();</span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            System.out.println(response);</span><br><span class="line">            <span class="comment">// 关闭client</span></span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果<br><img src="https://img-blog.csdnimg.cn/2020050316483727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2020050316483727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h3 id="3-1-向elasticsearch中添加索引"><a href="#3-1-向elasticsearch中添加索引" class="headerlink" title="3.1 向elasticsearch中添加索引"></a>3.1 向elasticsearch中添加索引</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> es;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.AdminClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.IndicesAdminClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.settings.Settings;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.transport.TransportAddress;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentBuilder;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.common.xcontent.XContentFactory;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.transport.client.PreBuiltTransportClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: EHRelasticsearch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 向elasticsearch中添加数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: huanshi2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-05-03 16:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@email</span>: 1557679224@qq.com</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdateEs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TransportClient client = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在所有的测试方法之前执行连接elasticsearch操作</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;resource&quot;)</span></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 设置集群名称 elasticsearch-cluster</span></span><br><span class="line">        Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;elasticsearch-cluster&quot;</span>)</span><br><span class="line">                <span class="comment">// 自动嗅探整个集群的状态，把集群中其他ES节点的ip添加到本地的客户端列表中</span></span><br><span class="line">                .put(<span class="string">&quot;client.transport.sniff&quot;</span>, <span class="keyword">true</span>).build();</span><br><span class="line">        <span class="comment">// 创建client</span></span><br><span class="line">        client = <span class="keyword">new</span> PreBuiltTransportClient(settings).addTransportAddresses(</span><br><span class="line">                <span class="comment">// 建议指定2个及其以上的节点。</span></span><br><span class="line">                <span class="comment">//节点个数由你安装的节点决定</span></span><br><span class="line">                <span class="keyword">new</span> TransportAddress(InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>), <span class="number">9300</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @Author huanshi2</span></span><br><span class="line"><span class="comment">     * @Description //测试向es中添加数据</span></span><br><span class="line"><span class="comment">     * @Date 2020/5/3 16:55</span></span><br><span class="line"><span class="comment">     * @email 1557679224@qq.com</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndexWithSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AdminClient admin = client.admin();</span><br><span class="line">        <span class="comment">// 使用Admin API对索引进行操作</span></span><br><span class="line">        IndicesAdminClient indices = admin.indices();</span><br><span class="line">        <span class="comment">// 准备创建索引</span></span><br><span class="line">        indices.prepareCreate(<span class="string">&quot;player&quot;</span>)</span><br><span class="line">                <span class="comment">// 配置索引参数</span></span><br><span class="line">                .setSettings(</span><br><span class="line">                        <span class="comment">// 参数配置器</span></span><br><span class="line">                        Settings.builder()<span class="comment">// 指定索引分区的数量。shards分区，</span></span><br><span class="line">                                .put(<span class="string">&quot;index.number_of_shards&quot;</span>, <span class="number">1</span>)</span><br><span class="line">                                <span class="comment">// 指定索引副本的数量(注意：不包括本身,如果设置数据存储副本为1,实际上数据存储了2份)</span></span><br><span class="line">                                <span class="comment">// 由于本机只用了单节点，这里replicas设置为0，不保存副本</span></span><br><span class="line">                                .put(<span class="string">&quot;index.number_of_replicas&quot;</span>, <span class="number">0</span>))</span><br><span class="line">                <span class="comment">// 真正执行</span></span><br><span class="line">                .get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试成功：<br><img src="https://img-blog.csdnimg.cn/2020050317090180.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2020050317090180.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>添加成功后，可以使用elasticsearch-head插件查看结果<br><img src="https://img-blog.csdnimg.cn/2020050317092818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2020050317092818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>可以看到我们的player索引创建成功。</p>
<h3 id="3-2-为索引添加Mapping和field"><a href="#3-2-为索引添加Mapping和field" class="headerlink" title="3.2 为索引添加Mapping和field"></a>3.2 为索引添加Mapping和field</h3><p>参考<a href="https://blog.csdn.net/sinat_35930259/article/details/80354732">https://blog.csdn.net/sinat_35930259/article/details/80354732</a><br>mapping是类似于数据库中的表结构定义，主要作用如下：</p>
<ul>
<li>定义index下的字段名</li>
<li>定义字段类型，比如数值型、浮点型、布尔型等</li>
<li>定义倒排索引相关的设置，比如是否索引、记录position等</li>
</ul>
<p>自定义mapping的API<br><img src="https://img-blog.csdn.net/20180517140331671?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM1OTMwMjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload" data-srcset="https://img-blog.csdn.net/20180517140331671?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM1OTMwMjU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt=""></p>
<p>查看已有的index的mapping<br><img src="https://img-blog.csdnimg.cn/20200503172646255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200503172646255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>设定索引<code>player</code>的·<code>mapping</code> ，把下面的代码加入到上面的java文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchSettingsPlayerMappings</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       XContentBuilder builder = XContentFactory.jsonBuilder().startObject()</span><br><span class="line">               .field(<span class="string">&quot;dynamic&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">               .startObject(<span class="string">&quot;properties&quot;</span>)</span><br><span class="line">               <span class="comment">// 在文档中存储、</span></span><br><span class="line">               .startObject(<span class="string">&quot;id&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;integer&quot;</span>).field(<span class="string">&quot;store&quot;</span>, <span class="string">&quot;true&quot;</span>).endObject()</span><br><span class="line">               <span class="comment">// 不分词,不建索引、</span></span><br><span class="line">               .startObject(<span class="string">&quot;name&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text&quot;</span>).field(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;false&quot;</span>).endObject()</span><br><span class="line">               <span class="comment">//</span></span><br><span class="line">               .startObject(<span class="string">&quot;age&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;integer&quot;</span>).endObject()</span><br><span class="line">               <span class="comment">//</span></span><br><span class="line">               .startObject(<span class="string">&quot;salary&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;integer&quot;</span>).endObject()</span><br><span class="line">               <span class="comment">// 不分词,不建建索引、</span></span><br><span class="line">               .startObject(<span class="string">&quot;team&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text&quot;</span>).field(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;false&quot;</span>).endObject()</span><br><span class="line">               <span class="comment">// 不分词,但是建索引、</span></span><br><span class="line">               .startObject(<span class="string">&quot;position&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text&quot;</span>).field(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;true&quot;</span>).endObject()</span><br><span class="line">               <span class="comment">// 即分词,又建立索引、</span></span><br><span class="line">               .startObject(<span class="string">&quot;description&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text&quot;</span>).field(<span class="string">&quot;store&quot;</span>, <span class="string">&quot;false&quot;</span>).field(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">               .field(<span class="string">&quot;analyzer&quot;</span>, <span class="string">&quot;ik_smart&quot;</span>).endObject()</span><br><span class="line">               <span class="comment">// 即分词,又建立索引、在文档中存储、</span></span><br><span class="line">               .startObject(<span class="string">&quot;addr&quot;</span>).field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;text&quot;</span>).field(<span class="string">&quot;store&quot;</span>, <span class="string">&quot;true&quot;</span>).field(<span class="string">&quot;index&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">               .field(<span class="string">&quot;analyzer&quot;</span>, <span class="string">&quot;ik_smart&quot;</span>).endObject()</span><br><span class="line">               .endObject()</span><br><span class="line">               .endObject();</span><br><span class="line"></span><br><span class="line">       CreateIndexRequestBuilder prepareCreate = client.admin().indices().prepareCreate(<span class="string">&quot;player&quot;</span>);</span><br><span class="line">       prepareCreate.addMapping(<span class="string">&quot;basketball&quot;</span>, builder).get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>mapping设定注意事项：</p>
<ol>
<li>mapping中的字段类型一旦设置，禁止直接修改，因为 lucene实现的倒排索引生成后不允许修改，应该重新建立新的索引，然后做reindex操作。 但是可以新增字段，通过 dynamic 参数来控制字段的新增，这个参数的值如下：<ul>
<li>true：默认值，表示允许选自动新增字段</li>
<li>false：不允许自动新增字段，但是文档可以正常写入，但无法对字段进行查询等操作</li>
<li>strict：严格模式，文档不能写入，报错</li>
</ul>
<ol start="2">
<li><code>elasticsearch5.x</code>以后，<code>string</code>type变为了<code>text</code></li>
<li>由于本机使用的单机单节点elasticsearch，所以每次添加索引时都需要指定分片和分副本数量</li>
</ol>
</li>
</ol>
<p>运行结果：<br><img src="https://img-blog.csdnimg.cn/20200503180248138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200503180248138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>查看mapping：<br><img src="https://img-blog.csdnimg.cn/20200503180342244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200503180342244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">&quot;player&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">   <span class="attr">&quot;basketball&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dynamic&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;addr&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,<span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,<span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>&#125;,</span><br><span class="line">            <span class="attr">&quot;age&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">            <span class="attr">&quot;description&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,<span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>&#125;,</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,<span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,<span class="attr">&quot;index&quot;</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>&#125;,</span><br><span class="line">            <span class="attr">&quot;salary&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>&#125;,</span><br><span class="line">            <span class="attr">&quot;team&quot;</span>: &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,<span class="attr">&quot;index&quot;</span>: <span class="literal">false</span>&#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自定义mapping成功！</p>
<h3 id="3-3-创建一个索引并添加数据"><a href="#3-3-创建一个索引并添加数据" class="headerlink" title="3.3 创建一个索引并添加数据"></a>3.3 创建一个索引并添加数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchCreate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       HashMap&lt;String, Object&gt; settings_map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">       <span class="comment">// shards分区的数量1</span></span><br><span class="line">       settings_map.put(<span class="string">&quot;number_of_shards&quot;</span>, <span class="number">1</span>);</span><br><span class="line">       <span class="comment">// 副本的数量0</span></span><br><span class="line">       settings_map.put(<span class="string">&quot;number_of_replicas&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       CreateIndexRequestBuilder prepareCreate = client.admin().indices().prepareCreate(<span class="string">&quot;student&quot;</span>);</span><br><span class="line"></span><br><span class="line">       prepareCreate.setSettings(settings_map).get();</span><br><span class="line"></span><br><span class="line">       IndexResponse response = client.prepareIndex(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">               .setSource(jsonBuilder().startObject().field(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>).field(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;man&quot;</span>)</span><br><span class="line">                       .field(<span class="string">&quot;birthday&quot;</span>, <span class="keyword">new</span> Date()).field(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>).field(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;using java to control Elasticsearch&quot;</span>)</span><br><span class="line">                       .endObject())</span><br><span class="line">               .get();</span><br><span class="line">       System.out.println(response.toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>添加成功<br><img src="https://img-blog.csdnimg.cn/2020050318301714.png" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2020050318301714.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>浏览数据：<br><img src="https://img-blog.csdnimg.cn/2020050318310395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2020050318310395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>添加成功!<br>再使用java查看刚才插入的数据<br><img src="https://img-blog.csdnimg.cn/2020050318351367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/2020050318351367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>插入成功。</p>
<p><strong>向指定索引指定Type的id的信息添加信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchAddPlayer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * @description: 向指定索引指定Type的id的信息添加信息</span></span><br><span class="line"><span class="comment">        * @Param: []</span></span><br><span class="line"><span class="comment">        * @Return: void</span></span><br><span class="line"><span class="comment">        * @Author: huanshi2</span></span><br><span class="line"><span class="comment">        * @Date: 2020/5/4 14:43</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        IndexResponse response = client.prepareIndex(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;9&quot;</span>)</span><br><span class="line">                .setSource(jsonBuilder().startObject()</span><br><span class="line">                        .field(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;安其拉&quot;</span>)</span><br><span class="line">                        .field(<span class="string">&quot;birthday&quot;</span>, <span class="keyword">new</span> Date())</span><br><span class="line">                        .field(<span class="string">&quot;age&quot;</span>, <span class="number">28</span>)</span><br><span class="line">                        .field(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;唱跳rap&quot;</span>)</span><br><span class="line">                        .endObject())</span><br><span class="line">                .get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>成功<br><img src="https://img-blog.csdnimg.cn/20200504144943888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200504144943888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>插入多条数据并遍历打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchMultiGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       IndexResponse response1 = client.prepareIndex(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">               .setSource(jsonBuilder().startObject().field(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lisi&quot;</span>).field(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;man&quot;</span>)</span><br><span class="line">                       .field(<span class="string">&quot;birthday&quot;</span>, <span class="keyword">new</span> Date()).field(<span class="string">&quot;age&quot;</span>, <span class="number">22</span>).field(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;using java to control Elasticsearch&quot;</span>)</span><br><span class="line">                       .endObject())</span><br><span class="line">               .get();</span><br><span class="line">       IndexResponse response2 = client.prepareIndex(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">               .setSource(jsonBuilder().startObject().field(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;wangwu&quot;</span>).field(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;man&quot;</span>)</span><br><span class="line">                       .field(<span class="string">&quot;birthday&quot;</span>, <span class="keyword">new</span> Date()).field(<span class="string">&quot;age&quot;</span>, <span class="number">23</span>).field(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;using java to control Elasticsearch&quot;</span>)</span><br><span class="line">                       .endObject())</span><br><span class="line">               .get();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//查找多个</span></span><br><span class="line">       MultiGetResponse multiGetItemResponses = client.prepareMultiGet().add(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>).get();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将查询出的结果遍历输出</span></span><br><span class="line">       <span class="keyword">for</span> (MultiGetItemResponse itemResponse : multiGetItemResponses) &#123;</span><br><span class="line">           <span class="comment">// 将每一个查询出的结果遍历输出</span></span><br><span class="line">           GetResponse response = itemResponse.getResponse();</span><br><span class="line">           <span class="comment">// 判断如果存在就进行遍历输出</span></span><br><span class="line">           <span class="keyword">if</span> (response.isExists()) &#123;</span><br><span class="line">               String json = response.getSourceAsString();</span><br><span class="line">               System.out.println(json);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：<br><img src="https://img-blog.csdnimg.cn/20200503185245979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200503185245979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h3 id="3-4-删除已经插入的数据"><a href="#3-4-删除已经插入的数据" class="headerlink" title="3.4 删除已经插入的数据"></a>3.4 删除已经插入的数据</h3><p>上代码：<br><strong>删除指定id的数据：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * @description: 删除指定id的数据</span></span><br><span class="line"><span class="comment">        * @Param: []</span></span><br><span class="line"><span class="comment">        * @Return: void</span></span><br><span class="line"><span class="comment">        * @Author: huanshi2</span></span><br><span class="line"><span class="comment">        * @Date: 2020/5/4 14:19</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 指定删除的id信息,并且给出响应结果</span></span><br><span class="line">        DeleteResponse response = client.prepareDelete(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;5&quot;</span>).get();</span><br><span class="line">        <span class="comment">// 打印输出的响应信息</span></span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200504142509402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200504142509402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>根据查询条件进行删除数据：<br>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchDeleteByQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * @description: 根据查询条件进行删除数据</span></span><br><span class="line"><span class="comment">         * @Param: []</span></span><br><span class="line"><span class="comment">         * @Return: void</span></span><br><span class="line"><span class="comment">         * @Author: huanshi2</span></span><br><span class="line"><span class="comment">         * @Date: 2020/5/4 14:27</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BulkByScrollResponse response = DeleteByQueryAction.INSTANCE.newRequestBuilder(client)</span><br><span class="line">                <span class="comment">// 指定查询条件,matchQuery是name的值text里面包括了这个内容就进行删除。默认使用标准分词器。</span></span><br><span class="line">                .filter(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王八&quot;</span>))</span><br><span class="line">                <span class="comment">// 指定索引名称</span></span><br><span class="line">                .source(<span class="string">&quot;student&quot;</span>).get();</span><br><span class="line">        <span class="comment">// 获取到删除的个数</span></span><br><span class="line">        <span class="keyword">long</span> deleted = response.getDeleted();</span><br><span class="line">        <span class="comment">// 打印输出删除的个数</span></span><br><span class="line">        System.out.println(deleted);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>删除成功</p>
<p><img src="https://img-blog.csdnimg.cn/20200504143408935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200504143408935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h3 id="3-5-修改elasticsearch中已经存储的数据"><a href="#3-5-修改elasticsearch中已经存储的数据" class="headerlink" title="3.5 修改elasticsearch中已经存储的数据"></a>3.5 修改elasticsearch中已经存储的数据</h3><p><strong>更新指定index指定type指定id的信息</strong><br>由于前面添加信息时忘记添加<code>sex</code>字段，这里直接修改为man</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * @description: 更新指定index指定type指定id的信息</span></span><br><span class="line"><span class="comment">        * @Param: []</span></span><br><span class="line"><span class="comment">        * @Return: void</span></span><br><span class="line"><span class="comment">        * @Author: huanshi2</span></span><br><span class="line"><span class="comment">        * @Date: 2020/5/4 14:54</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 创建一个更新的请求对象</span></span><br><span class="line">        UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest();</span><br><span class="line">        <span class="comment">// 指定索引Index</span></span><br><span class="line">        updateRequest.index(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定类型Type</span></span><br><span class="line">        updateRequest.type(<span class="string">&quot;classone&quot;</span>);</span><br><span class="line">        <span class="comment">// 指定id的值</span></span><br><span class="line">        updateRequest.id(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置修改的字段信息</span></span><br><span class="line">        updateRequest.doc(jsonBuilder().startObject().field(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;吕布&quot;</span>).field(<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;man&quot;</span>).endObject());</span><br><span class="line">        <span class="comment">// 开始进行修改，并且返回响应信息</span></span><br><span class="line">        UpdateResponse updateResponse = client.update(updateRequest).get();</span><br><span class="line">        <span class="comment">// 打印输出响应的信息</span></span><br><span class="line">        System.out.println(updateResponse.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>修改成功<br><img src="https://img-blog.csdnimg.cn/20200504150015238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200504150015238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<h3 id="3-6-查找数据"><a href="#3-6-查找数据" class="headerlink" title="3.6 查找数据"></a>3.6 查找数据</h3><p>根据id查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        GetResponse response = client.prepareGet(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;9&quot;</span>).get();</span><br><span class="line">        System.out.println(response.getSourceAsString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据指定index，指定type，指定id查找</p>
<p>注意：6.0的版本不允许一个index下面有多个type，在接下来的7.0版本中会删掉type</p>
<blockquote>
<p><a href="https://www.cnblogs.com/yfb918/p/10690103.html">https://www.cnblogs.com/yfb918/p/10690103.html</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchMultiGet</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * @description: 查询出多个索引Index多个类型Type的多个id的所有信息</span></span><br><span class="line"><span class="comment">        * @Param: []</span></span><br><span class="line"><span class="comment">        * @Return: void</span></span><br><span class="line"><span class="comment">        * @Author: huanshi2</span></span><br><span class="line"><span class="comment">        * @Date: 2020/5/4 15:07</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        MultiGetResponse multiGetItemResponses = client.prepareMultiGet().add(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;10&quot;</span>)</span><br><span class="line">                .add(<span class="string">&quot;student&quot;</span>, <span class="string">&quot;classone&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>,<span class="string">&quot;9&quot;</span>).add(<span class="string">&quot;teacher&quot;</span>, <span class="string">&quot;classtwo&quot;</span>, <span class="string">&quot;11&quot;</span>).get();</span><br><span class="line">        <span class="comment">// 将查询出的结果遍历输出</span></span><br><span class="line">        <span class="keyword">for</span> (MultiGetItemResponse itemResponse : multiGetItemResponses) &#123;</span><br><span class="line">            <span class="comment">// 将每一个查询出的结果遍历输出</span></span><br><span class="line">            GetResponse response = itemResponse.getResponse();</span><br><span class="line">            <span class="comment">// 判断如果存在就进行遍历输出</span></span><br><span class="line">            <span class="keyword">if</span> (response.isExists()) &#123;</span><br><span class="line">                String json = response.getSourceAsString();</span><br><span class="line">                System.out.println(json);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果<br><img src="https://img-blog.csdnimg.cn/20200504152621764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200504152621764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"><br>范围查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">elasticsearchRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * @description: 范围查找</span></span><br><span class="line"><span class="comment">        * @Param: []</span></span><br><span class="line"><span class="comment">        * @Return: void</span></span><br><span class="line"><span class="comment">        * @Author: huanshi2</span></span><br><span class="line"><span class="comment">        * @Date: 2020/5/4 15:29</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// includeLower(true).includeUpper(false)含义是包含前面,不包含后面的</span></span><br><span class="line">        <span class="comment">// [21, 24)</span></span><br><span class="line">        QueryBuilder qb = rangeQuery(<span class="string">&quot;age&quot;</span>).from(<span class="number">21</span>).to(<span class="number">24</span>).includeLower(<span class="keyword">true</span>).includeUpper(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 将查询条件传递进去,并将查询结果进行返回。</span></span><br><span class="line">        SearchResponse response = client.prepareSearch(<span class="string">&quot;student&quot;</span>).setQuery(qb).get();</span><br><span class="line">        System.out.println(response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="https://img-blog.csdnimg.cn/20200504153049676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200504153049676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTE0Nzg5,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p>
<p>github地址：<a href="https://github.com/huanshi2/EHRelasticsearch">https://github.com/huanshi2/EHRelasticsearch</a></p>
<p>代码查考了下列的博客文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/Mr_OOO/article/details/79518978">https://blog.csdn.net/Mr_OOO/article/details/79518978</a><br><a href="https://www.cnblogs.com/biehongli/p/11710704.html"> https://www.cnblogs.com/biehongli/p/11710704.html</a><br><a href="https://www.cnblogs.com/chenyuanbo/p/10296809.html">https://www.cnblogs.com/chenyuanbo/p/10296809.html</a><br><a href="https://blog.csdn.net/fulishafulisha/article/details/80158392">https://blog.csdn.net/fulishafulisha/article/details/80158392</a><br><a href="https://www.cnblogs.com/cjsblog/p/10035629.html">https://www.cnblogs.com/cjsblog/p/10035629.html</a><br><a href="https://www.cnblogs.com/yfb918/p/10690103.html">https://www.cnblogs.com/yfb918/p/10690103.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>毕设</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
</search>
